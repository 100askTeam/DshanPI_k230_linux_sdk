From 085b2f6ec070e596a56a71a29dfb789578310e43 Mon Sep 17 00:00:00 2001
From: wangjianxin <wangjianxin@canaan-creative.com>
Date: Tue, 11 Jun 2024 16:54:25 +0800
Subject: [PATCH 12/20] k230 gpu driver

---
 drivers/gpu/Makefile                          |   2 +-
 drivers/gpu/drm/Kconfig                       |   2 +
 drivers/gpu/drm/Makefile                      |   1 +
 drivers/gpu/drm/canaan/Kconfig                |  24 +
 drivers/gpu/drm/canaan/Makefile               |  10 +
 drivers/gpu/drm/canaan/canaan_crtc.c          | 167 ++++
 drivers/gpu/drm/canaan/canaan_crtc.h          |  26 +
 drivers/gpu/drm/canaan/canaan_drv.c           | 275 ++++++
 drivers/gpu/drm/canaan/canaan_drv.h           |  14 +
 drivers/gpu/drm/canaan/canaan_dsi.c           | 622 ++++++++++++
 drivers/gpu/drm/canaan/canaan_dsi.h           |  54 ++
 drivers/gpu/drm/canaan/canaan_phy.c           | 241 +++++
 drivers/gpu/drm/canaan/canaan_plane.c         | 136 +++
 drivers/gpu/drm/canaan/canaan_plane.h         |  40 +
 drivers/gpu/drm/canaan/canaan_vo.c            | 646 +++++++++++++
 drivers/gpu/drm/canaan/canaan_vo.h            |  40 +
 drivers/gpu/drm/canaan/canaan_vo_regs.h       | 222 +++++
 drivers/gpu/drm/canaan/canaan_vo_table.h      | 615 ++++++++++++
 drivers/gpu/drm/panel/Kconfig                 |   9 +
 drivers/gpu/drm/panel/Makefile                |   1 +
 .../gpu/drm/panel/panel-canaan-universal.c    | 419 ++++++++
 drivers/gpu/vglite/Kconfig                    |   6 +
 drivers/gpu/vglite/Makefile                   |   3 +
 drivers/gpu/vglite/vg_lite_debug.h            |  85 ++
 drivers/gpu/vglite/vg_lite_hal.c              | 908 ++++++++++++++++++
 drivers/gpu/vglite/vg_lite_hal.h              | 286 ++++++
 drivers/gpu/vglite/vg_lite_hw.h               |  90 ++
 drivers/gpu/vglite/vg_lite_ioctl.h            |  70 ++
 drivers/gpu/vglite/vg_lite_kernel.c           | 861 +++++++++++++++++
 drivers/gpu/vglite/vg_lite_kernel.h           | 525 ++++++++++
 drivers/gpu/vglite/vg_lite_options.h          |  86 ++
 drivers/gpu/vglite/vg_lite_platform.h         |  57 ++
 drivers/gpu/vglite/vg_lite_type.h             |  74 ++
 33 files changed, 6616 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/canaan/Kconfig
 create mode 100644 drivers/gpu/drm/canaan/Makefile
 create mode 100755 drivers/gpu/drm/canaan/canaan_crtc.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_crtc.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_drv.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_drv.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_dsi.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_dsi.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_phy.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_plane.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_plane.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_vo.c
 create mode 100755 drivers/gpu/drm/canaan/canaan_vo.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_vo_regs.h
 create mode 100755 drivers/gpu/drm/canaan/canaan_vo_table.h
 create mode 100644 drivers/gpu/drm/panel/panel-canaan-universal.c
 create mode 100644 drivers/gpu/vglite/Kconfig
 create mode 100644 drivers/gpu/vglite/Makefile
 create mode 100644 drivers/gpu/vglite/vg_lite_debug.h
 create mode 100644 drivers/gpu/vglite/vg_lite_hal.c
 create mode 100644 drivers/gpu/vglite/vg_lite_hal.h
 create mode 100644 drivers/gpu/vglite/vg_lite_hw.h
 create mode 100644 drivers/gpu/vglite/vg_lite_ioctl.h
 create mode 100644 drivers/gpu/vglite/vg_lite_kernel.c
 create mode 100644 drivers/gpu/vglite/vg_lite_kernel.h
 create mode 100644 drivers/gpu/vglite/vg_lite_options.h
 create mode 100644 drivers/gpu/vglite/vg_lite_platform.h
 create mode 100644 drivers/gpu/vglite/vg_lite_type.h

diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index 8997f0096..e11227355 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -2,6 +2,6 @@
 # drm/tegra depends on host1x, so if both drivers are built-in care must be
 # taken to initialize them in the correct order. Link order is the only way
 # to ensure this currently.
-obj-y			+= host1x/ drm/ vga/
+obj-y			+= host1x/ drm/ vga/ vglite/
 obj-$(CONFIG_IMX_IPUV3_CORE)	+= ipu-v3/
 obj-$(CONFIG_TRACE_GPU_MEM)		+= trace/
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 3caa02039..67b7fc6ed 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -387,6 +387,8 @@ source "drivers/gpu/drm/solomon/Kconfig"
 
 source "drivers/gpu/drm/sprd/Kconfig"
 
+source "drivers/gpu/drm/canaan/Kconfig"
+
 config DRM_HYPERV
 	tristate "DRM Support for Hyper-V synthetic video device"
 	depends on DRM && PCI && MMU && HYPERV
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 215e78e79..0659710e5 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -198,3 +198,4 @@ obj-$(CONFIG_DRM_HYPERV) += hyperv/
 obj-y			+= solomon/
 obj-$(CONFIG_DRM_SPRD) += sprd/
 obj-$(CONFIG_DRM_LOONGSON) += loongson/
+obj-$(CONFIG_DRM_CANAAN) += canaan/
diff --git a/drivers/gpu/drm/canaan/Kconfig b/drivers/gpu/drm/canaan/Kconfig
new file mode 100644
index 000000000..b0df28548
--- /dev/null
+++ b/drivers/gpu/drm/canaan/Kconfig
@@ -0,0 +1,24 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config DRM_CANAAN
+    bool "DRM Support for Canaan K230 Display Controller"
+    depends on OF
+    depends on COMMON_CLK
+    select DRM
+    select DRM_KMS_HELPER
+    select DRM_KMS_DMA_HELPER
+    select DRM_GEM_DMA_HELPER
+    select VIDEOMODE_HELPERS
+    default ARCH_CANAAN
+    help
+        Choose this option to enable DRM on Canaan K230 chipset
+
+if DRM_CANAAN
+
+config DRM_CANAAN_DSI
+	bool "Canaan K230 MIPI-DSI Controller Support"
+	select DRM_MIPI_DSI
+        default DRM_CANAAN
+	help
+        Choose this option to enable Canaan K230 MIPI-DSI Controller
+
+endif
diff --git a/drivers/gpu/drm/canaan/Makefile b/drivers/gpu/drm/canaan/Makefile
new file mode 100644
index 000000000..e547cca4c
--- /dev/null
+++ b/drivers/gpu/drm/canaan/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-only
+canaan-drm-y := \
+		canaan_drv.o \
+		canaan_vo.o \
+		canaan_crtc.o \
+		canaan_plane.o \
+		canaan_phy.o
+
+obj-$(CONFIG_DRM_CANAAN) += canaan-drm.o
+obj-$(CONFIG_DRM_CANAAN_DSI) += canaan_dsi.o
diff --git a/drivers/gpu/drm/canaan/canaan_crtc.c b/drivers/gpu/drm/canaan/canaan_crtc.c
new file mode 100755
index 000000000..fa7c2bd65
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_crtc.c
@@ -0,0 +1,167 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_of.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+#include <drm/drm_irq.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#else
+#include <drm/drm_crtc_helper.h>
+#endif
+#include <drm/drm_vblank.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_print.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
+
+#include "canaan_vo.h"
+#include "canaan_crtc.h"
+#include "canaan_plane.h"
+
+static int canaan_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+    struct canaan_crtc *canaan_crtc = to_canaan_crtc(crtc);
+    struct canaan_vo *vo = canaan_crtc->vo;
+
+    DRM_DEBUG_DRIVER("Enable vblank on CRTC:%d\n", crtc->base.id);
+    return canaan_vo_enable_vblank(vo);
+}
+
+static void canaan_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+    struct canaan_crtc *canaan_crtc = to_canaan_crtc(crtc);
+    struct canaan_vo *vo = canaan_crtc->vo;
+
+    DRM_DEBUG_DRIVER("Disable vblank on CRTC:%d\n", crtc->base.id);
+    canaan_vo_disable_vblank(vo);
+}
+
+static void canaan_crtc_atomic_enable(struct drm_crtc *crtc,
+                                struct drm_atomic_state *old_crtc_state)
+{
+    struct canaan_crtc *canaan_crtc = to_canaan_crtc(crtc);
+    struct canaan_vo *vo = canaan_crtc->vo;
+    struct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;
+
+    DRM_DEBUG_DRIVER("Enable the CRTC:%d\n", crtc->base.id);
+
+    
+    canaan_vo_enable_crtc(vo, canaan_crtc, adjusted_mode);
+    drm_crtc_vblank_on(crtc);
+}
+
+static void canaan_crtc_atomic_disable(struct drm_crtc *crtc,
+                                struct drm_atomic_state *old_crtc_state)
+{
+    struct canaan_crtc *canaan_crtc = to_canaan_crtc(crtc);
+    struct canaan_vo *vo = canaan_crtc->vo;
+
+    DRM_DEBUG_DRIVER("Disable the CRTC:%d\n", crtc->base.id);
+    drm_crtc_vblank_off(crtc);
+    canaan_vo_disable_crtc(vo, canaan_crtc);
+
+    if (crtc->state->event && !crtc->state->active) {
+        spin_lock_irq(&crtc->dev->event_lock);
+        drm_crtc_send_vblank_event(crtc, crtc->state->event);
+        spin_unlock_irq(&crtc->dev->event_lock);
+
+        crtc->state->event = NULL;
+    }
+}
+
+static void canaan_crtc_atomic_flush(struct drm_crtc *crtc,
+                                struct drm_atomic_state *old_crtc_state)
+{
+    struct canaan_crtc *canaan_crtc = to_canaan_crtc(crtc);
+    struct canaan_vo *vo = canaan_crtc->vo;
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+    DRM_DEBUG_DRIVER("Flush the configuration \n");
+    canaan_vo_flush_config(vo);
+
+	if (event) {
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_arm_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+}
+
+static const struct drm_crtc_funcs canaan_crtc_funcs = {
+    .reset = drm_atomic_helper_crtc_reset,
+    .destroy = drm_crtc_cleanup,
+    .set_config = drm_atomic_helper_set_config,
+    .page_flip = drm_atomic_helper_page_flip,
+    #if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 14, 0)
+    .gamma_set = drm_atomic_helper_legacy_gamma_set,
+    #endif
+    .atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+    .enable_vblank = canaan_crtc_enable_vblank,
+    .disable_vblank = canaan_crtc_disable_vblank,
+};
+
+static const struct drm_crtc_helper_funcs canaan_crtc_helper_funcs = {
+    .atomic_enable = canaan_crtc_atomic_enable,
+    .atomic_disable = canaan_crtc_atomic_disable,
+    .atomic_flush = canaan_crtc_atomic_flush,
+};
+
+struct canaan_crtc *canaan_crtc_create(struct drm_device *drm_dev,
+                                struct drm_plane *primary, struct drm_plane *cursor,
+                                struct canaan_vo *vo)
+{
+    int ret = 0;
+    struct canaan_crtc *canaan_crtc = NULL;
+    struct drm_crtc *crtc = NULL;
+    struct device *dev = vo->dev;
+
+    canaan_crtc = devm_kzalloc(dev, sizeof(struct canaan_crtc), GFP_KERNEL);
+    if (!canaan_crtc)
+        return ERR_PTR(-ENOMEM);
+    canaan_crtc->vo = vo;
+    crtc = &canaan_crtc->base;
+
+    ret = drm_crtc_init_with_planes(drm_dev, crtc,
+                                    primary, cursor,
+                                    &canaan_crtc_funcs, "canaan_crtc");
+    if (ret) {
+        return ERR_PTR(ret);
+        DRM_DEV_ERROR(dev, "Failed to init CRTC \n");
+    }
+
+    drm_crtc_helper_add(crtc, &canaan_crtc_helper_funcs);
+
+    drm_mode_crtc_set_gamma_size(crtc, 256);
+    drm_crtc_enable_color_mgmt(crtc, 0, false, 256);
+    DRM_DEBUG_DRIVER("Create the CRTC:%d\n", crtc->base.id);
+
+    return canaan_crtc;
+}
+
diff --git a/drivers/gpu/drm/canaan/canaan_crtc.h b/drivers/gpu/drm/canaan/canaan_crtc.h
new file mode 100755
index 000000000..3d57140cd
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_crtc.h
@@ -0,0 +1,26 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_CRTC_H__
+#define __CANAAN_CRTC_H__
+
+struct canaan_crtc {
+    struct drm_crtc     base;
+    struct canaan_vo    *vo;
+    struct drm_pending_vblank_event *event;
+};
+
+static inline struct canaan_crtc *to_canaan_crtc(struct drm_crtc *crtc)
+{
+    return container_of(crtc, struct canaan_crtc, base);
+}
+
+struct canaan_crtc *canaan_crtc_create(struct drm_device *drm_dev,
+                                struct drm_plane *primary, struct drm_plane *cursor,
+                                struct canaan_vo *vo);
+
+#endif /* __CANAAN_CRTC_H__ */
diff --git a/drivers/gpu/drm/canaan/canaan_drv.c b/drivers/gpu/drm/canaan/canaan_drv.c
new file mode 100755
index 000000000..1c98014ea
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_drv.c
@@ -0,0 +1,275 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/fs.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_of.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+#include <drm/drm_irq.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#else
+#include <drm/drm_gem_dma_helper.h>
+#include <drm/drm_fbdev_generic.h>
+#endif
+#include <drm/drm_vblank.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_print.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+
+#include "canaan_drv.h"
+#include "canaan_vo.h"
+
+static int canaan_drm_open(struct inode *inode, struct file *filp);
+static int canaan_drm_release(struct inode *inode, struct file *filp);
+
+static const struct file_operations canaan_drm_fops = {
+    .owner		= THIS_MODULE,
+    .open		= canaan_drm_open,
+    .release	= canaan_drm_release,
+    .unlocked_ioctl	= drm_ioctl,
+    .compat_ioctl	= drm_compat_ioctl,
+    .poll		= drm_poll,
+    .read		= drm_read,
+    .llseek		= noop_llseek,
+    .mmap		= drm_gem_mmap,
+    DRM_GEM_DMA_UNMAPPED_AREA_FOPS
+};
+
+static struct drm_driver canaan_drm_driver = {
+    .driver_features    = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+    DRM_GEM_DMA_DRIVER_OPS_VMAP,
+    .fops               = &canaan_drm_fops,
+    .name               = "canaan-drm",
+    .desc               = "Canaan K230 DRM driver",
+    .date               = "20230501",
+    .major              = 1,
+    .minor              = 0,
+};
+
+static const struct drm_mode_config_funcs canaan_drm_mode_config_funcs = {
+    .fb_create = drm_gem_fb_create,
+    .atomic_check = drm_atomic_helper_check,
+    .atomic_commit = drm_atomic_helper_commit,
+};
+
+static const struct drm_mode_config_helper_funcs canaan_drm_mode_config_helpers = {
+    .atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,
+};
+
+static struct device *disp_dev;
+
+static int canaan_drm_open(struct inode *inode, struct file *filp)
+{
+    int ret;
+
+    pm_runtime_get_sync(disp_dev);
+    ret = drm_open(inode, filp);
+
+    return ret;
+}
+
+static int canaan_drm_release(struct inode *inode, struct file *filp)
+{
+    int ret;
+
+    ret = drm_release(inode, filp);
+    // pm_runtime_put_sync(disp_dev);
+
+    return ret;
+}
+
+static int canaan_drm_bind(struct device *dev)
+{
+    int ret = 0;
+    struct drm_device *drm_dev;
+
+    drm_dev = drm_dev_alloc(&canaan_drm_driver, dev);
+    if (IS_ERR(drm_dev))
+        return PTR_ERR(drm_dev);
+    dev_set_drvdata(dev, drm_dev);
+
+    drm_mode_config_init(drm_dev);
+    drm_dev->mode_config.min_width = 16;
+    drm_dev->mode_config.min_height = 16;
+    drm_dev->mode_config.max_width = 4096;
+    drm_dev->mode_config.max_height = 4096;
+    drm_dev->mode_config.normalize_zpos = true;
+    drm_dev->mode_config.funcs = &canaan_drm_mode_config_funcs;
+    drm_dev->mode_config.helper_private = &canaan_drm_mode_config_helpers;
+
+    ret = component_bind_all(dev, drm_dev);
+    if (ret) {
+        DRM_DEV_ERROR(dev, "Failed to bind all components \n");
+        goto cleanup_mode_config;
+    }
+
+    ret = drm_vblank_init(drm_dev, drm_dev->mode_config.num_crtc);
+    if (ret) {
+        DRM_DEV_ERROR(dev, "Failed to init vblank \n");
+        goto unbind_all;
+    }
+
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+    drm_dev->irq_enabled = true;
+    #endif
+    drm_mode_config_reset(drm_dev);
+    drm_kms_helper_poll_init(drm_dev);
+
+    ret = drm_dev_register(drm_dev, 0);
+    if (ret) {
+        DRM_DEV_ERROR(dev, "Failed to register drm device \n");
+        goto finish_poll;
+    }
+
+    drm_fbdev_generic_setup(drm_dev, 32);
+    DRM_DEV_INFO(dev, "Canaan K230 DRM driver register successfully \n");
+
+    return 0;
+
+finish_poll:
+    drm_kms_helper_poll_fini(drm_dev);
+unbind_all:
+    component_unbind_all(dev, drm_dev);
+cleanup_mode_config:
+    drm_mode_config_cleanup(drm_dev);
+
+    dev_set_drvdata(dev, NULL);
+    drm_dev_put(drm_dev);
+    return ret;
+}
+
+static void canaan_drm_unbind(struct device *dev)
+{
+    struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+    drm_dev_unregister(drm_dev);
+    drm_kms_helper_poll_fini(drm_dev);
+    drm_atomic_helper_shutdown(drm_dev);
+    component_unbind_all(dev, drm_dev);
+    drm_mode_config_cleanup(drm_dev);
+    dev_set_drvdata(dev, NULL);
+    drm_dev_put(drm_dev);
+}
+
+static const struct component_master_ops canaan_drm_master_ops = {
+    .bind   = canaan_drm_bind,
+    .unbind = canaan_drm_unbind,
+};
+
+static struct platform_driver *const component_drivers[] = {
+    &canaan_vo_driver,
+    &canaan_dsi_driver,
+};
+
+static int compare_dev(struct device *dev, void *data)
+{
+    return dev == (struct device *)data;
+}
+
+static struct component_match *canaan_drm_match_add(struct device *dev)
+{
+    int i = 0;
+    struct component_match *match = NULL;
+
+    for (i = 0; i < ARRAY_SIZE(component_drivers); i++) {
+        struct device_driver *driver = &component_drivers[i]->driver;
+        struct device *p = NULL, *d;
+
+        while ((d = platform_find_device_by_driver(p, driver))) {
+            put_device(p);
+            component_match_add(dev, &match, compare_dev, d);
+            p = d;
+        }
+        put_device(p);
+    }
+
+    return match ?: ERR_PTR(-ENODEV);
+}
+
+static int canaan_drm_platform_probe(struct platform_device *pdev)
+{
+    struct device *dev = &pdev->dev;
+    struct component_match *match = NULL;
+
+    disp_dev = dev;
+    pm_runtime_enable(disp_dev);
+    match = canaan_drm_match_add(dev);
+    if (IS_ERR(match))
+        return PTR_ERR(match);
+
+    return component_master_add_with_match(dev, &canaan_drm_master_ops, match);
+}
+
+static int canaan_drm_platform_remove(struct platform_device *pdev)
+{
+    component_master_del(&pdev->dev, &canaan_drm_master_ops);
+
+    return 0;
+}
+
+static const struct of_device_id canaan_drm_of_table[] = {
+	{ .compatible = "canaan,display-subsystem", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, canaan_drm_of_table);
+
+static struct platform_driver canaan_drm_platform_driver = {
+	.probe = canaan_drm_platform_probe,
+	.remove = canaan_drm_platform_remove,
+	.driver = {
+		.name = "canaan-drm",
+		.of_match_table = canaan_drm_of_table,
+	},
+};
+
+static int __init canaan_drm_init(void)
+{
+    int ret = 0;
+
+    printk("canaan DRM init\n");
+    ret = platform_register_drivers(component_drivers,
+                            ARRAY_SIZE(component_drivers));
+    if (ret)
+        return ret;
+
+    ret = platform_driver_register(&canaan_drm_platform_driver);
+    if (ret)
+        platform_unregister_drivers(component_drivers,
+                            ARRAY_SIZE(component_drivers));
+
+    return ret;
+}
+
+static void __exit canaan_drm_exit(void)
+{
+    platform_unregister_drivers(component_drivers,
+                        ARRAY_SIZE(component_drivers));
+    platform_driver_unregister(&canaan_drm_platform_driver);
+}
+
+module_init(canaan_drm_init);
+module_exit(canaan_drm_exit);
+
+MODULE_DESCRIPTION("Canaan K230 DRM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/canaan/canaan_drv.h b/drivers/gpu/drm/canaan/canaan_drv.h
new file mode 100755
index 000000000..1617e14f9
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_drv.h
@@ -0,0 +1,14 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_DRV_H__
+#define __CANAAN_DRV_H__
+
+extern struct platform_driver canaan_vo_driver;
+extern struct platform_driver canaan_dsi_driver;
+
+#endif /* __CANAAN_DRV_H__ */
diff --git a/drivers/gpu/drm/canaan/canaan_dsi.c b/drivers/gpu/drm/canaan/canaan_dsi.c
new file mode 100755
index 000000000..73db5f807
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_dsi.c
@@ -0,0 +1,622 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/crc-ccitt.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy-mipi-dphy.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+#include "canaan_dsi.h"
+#include <video/mipi_display.h>
+
+#define DSI_GEN_HDR				0x6c
+#define DSI_GEN_PLD_DATA		0x70
+#define DSI_CMD_PKT_STATUS		0x74
+#define GEN_RD_CMD_BUSY			BIT(6)
+#define GEN_PLD_R_FULL			BIT(5)
+#define GEN_PLD_R_EMPTY			BIT(4)
+#define GEN_PLD_W_FULL			BIT(3)
+#define GEN_PLD_W_EMPTY			BIT(2)
+#define GEN_CMD_FULL			BIT(1)
+#define GEN_CMD_EMPTY			BIT(0)
+#define PHY_IF_CFG              (0xa4)
+#define CLKMGR_CFG              (0x08)
+#define GEN_VCID                (0x30)
+#define VID_PKT_SIZE            (0x3c)
+#define VID_NUM_CHUNKS          (0x40)
+#define VID_NULL_SIZE           (0x44)
+#define VID_HSA_TIME            (0x48)
+#define VID_HBP_TIME            (0x4c)
+#define VID_HLINE_TIME          (0x50)
+#define VID_VSA_LINES           (0x54)
+#define VID_VBP_LINES           (0x58)
+#define VID_VFP_LINES           (0x5c)
+#define VID_VACTIVE_LINES       (0x60)
+#define DSI_TO_CNT_CFG			0x78
+#define HSTX_TO_CNT(p)			(((p) & 0xffff) << 16)
+#define LPRX_TO_CNT(p)			((p) & 0xffff)
+#define DSI_BTA_TO_CNT			0x8c
+#define MODE_CFG                (0x34)
+#define VID_MODE_CFG            (0x38)
+#define CMD_MODE_CFG            (0x68)
+#define DPI_COLOR_CODING        (0x10)
+#define LPCLK_CTRL              (0x94)
+#define PCKHDL_CFG              (0x2c)
+
+#define CMD_PKT_STATUS_TIMEOUT_US	20000
+
+#define TXPHY_445_5_M           (295)
+#define TXPHY_445_5_N           (15)
+#define TXPHY_445_5_VOC         (0x17)
+#define TXPHY_445_5_HS_FREQ     (0x96)
+
+#define TXPHY_891_M             (165)
+#define TXPHY_891_N             (8)
+#define TXPHY_891_VOC           (0x09)
+#define TXPHY_891_HS_FREQ       (0x96)
+
+
+static inline void dsi_write(struct canaan_dsi *dsi, u32 reg, u32 val)
+{
+	writel(val, dsi->base + reg);
+}
+
+static inline u32 dsi_read(struct canaan_dsi *dsi, u32 reg)
+{
+	return readl(dsi->base + reg);
+}
+
+
+static void canaan_dsi_inst_abort(struct canaan_dsi *dsi)
+{
+	// TODO
+}
+
+static int canaan_dsi_inst_wait_for_completion(struct canaan_dsi *dsi)
+{
+	// TODO
+	return 0;
+}
+
+static int dw_mipi_dsi_gen_pkt_hdr_write(struct canaan_dsi *dsi, u32 hdr_val)
+{
+	int ret;
+	u32 val;
+
+	ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+				 val, !(val & GEN_CMD_FULL), 1000,
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret) {
+		dev_err(dsi->dev, "failed to get available command FIFO\n");
+		return ret;
+	}
+
+	dsi_write(dsi, DSI_GEN_HDR, hdr_val);
+	return 0;
+}
+
+static int canaan_dsi_dcs_write_short(struct canaan_dsi *dsi,
+				     const struct mipi_dsi_msg *msg)
+{
+	uint32_t hdr_val = 0;
+	uint32_t vcid = msg->channel;
+	__le32 word = 0;
+	const u8 *tx_buf = msg->tx_buf;
+
+	hdr_val = (tx_buf[0] << 8) + (vcid << 6) + 0x5;
+	memcpy(&word, &hdr_val, sizeof(hdr_val));
+	return dw_mipi_dsi_gen_pkt_hdr_write(dsi, le32_to_cpu(word));
+}
+
+static int canaan_dsi_dcs_write_long(struct canaan_dsi *dsi,
+				    const struct mipi_dsi_msg *msg)
+{
+	int ret = 0;
+	uint32_t val;
+	uint32_t hdr_val = 0;
+	uint32_t len = msg->tx_len;
+	uint32_t pld_data_bytes = sizeof(u32);
+	uint32_t vcid = msg->channel;
+	__le32 word;
+	const u8 *tx_buf = msg->tx_buf;
+
+	while (len) {
+		if (len < pld_data_bytes) {
+			word = 0;
+			memcpy(&word, tx_buf, len);
+			dsi_write(dsi, DSI_GEN_PLD_DATA, le32_to_cpu(word));
+			len = 0;
+		} else {
+			memcpy(&word, tx_buf, pld_data_bytes);
+			dsi_write(dsi, DSI_GEN_PLD_DATA, le32_to_cpu(word));
+			tx_buf += pld_data_bytes;
+			len -= pld_data_bytes;
+		}
+
+		ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+					 val, !(val & GEN_PLD_W_FULL), 1000,
+					 CMD_PKT_STATUS_TIMEOUT_US);
+		if (ret) {
+			dev_err(dsi->dev,
+				"failed to get available write payload FIFO\n");
+			return ret;
+		}
+	}
+	word = 0;
+	// set cmd tpye
+	hdr_val = (msg->tx_len << 8) + (vcid << 6) + 0x39;
+	memcpy(&word, &hdr_val, sizeof(hdr_val));
+	return dw_mipi_dsi_gen_pkt_hdr_write(dsi, le32_to_cpu(word));
+}
+
+static int canaan_dsi_dcs_read(struct canaan_dsi *dsi,
+			      const struct mipi_dsi_msg *msg)
+{
+	// TODO
+	return 1;
+}
+
+static void canaan_dsi_set_lan_num(struct canaan_dsi *dsi, int lan_num)
+{
+	switch(lan_num)
+	{
+		case 1:
+			dsi_write(dsi, PHY_IF_CFG, 0x2800);
+			break;
+		case 2:
+			dsi_write(dsi, PHY_IF_CFG, 0x2801);
+			break;
+		case 4:
+			dsi_write(dsi, PHY_IF_CFG, 0x2803);
+			break;
+		default :
+			printk("dsi lan num only support 1 , 2, 4 lane \n");
+			break;
+	}
+}
+
+
+static u32 canaan_dsi_get_hcomponent_lbcc(struct canaan_dsi *dsi,
+					   const struct drm_display_mode *mode,
+					   u32 hcomponent)
+{
+	u32 frac, lbcc;
+
+	lbcc = hcomponent * dsi->phy_freq / 8;
+
+	frac = lbcc % mode->clock;
+	lbcc = lbcc / mode->clock;
+	if (frac)
+		lbcc++;
+
+	return lbcc;
+}
+
+
+static void canaan_dsi_set_dpi_timing(struct canaan_dsi *dsi, struct drm_display_mode *mode)
+{
+	u32 htotal, hsa, hbp, hact, lbcc, vsa, vbp, vfp, vact;
+
+	htotal = mode->htotal;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	hact = mode->hdisplay;
+
+	vsa = mode->vsync_end - mode->vsync_start;
+	vbp = mode->vtotal - mode->vsync_end;
+	vact = mode->vdisplay;
+	vfp = mode->vtotal - vsa - vbp - vact;
+
+	dsi_write(dsi, VID_PKT_SIZE, hact);
+	dsi_write(dsi, VID_NUM_CHUNKS, 0);
+	dsi_write(dsi, VID_NULL_SIZE, 0);
+
+	// set hsa
+	lbcc = canaan_dsi_get_hcomponent_lbcc(dsi, mode, hsa);
+	dsi_write(dsi, VID_HSA_TIME, lbcc);
+
+	// set hbp
+	lbcc = canaan_dsi_get_hcomponent_lbcc(dsi, mode, hbp);
+	dsi_write(dsi, VID_HBP_TIME, lbcc);
+
+	// set hline
+	lbcc = canaan_dsi_get_hcomponent_lbcc(dsi, mode, htotal);
+	dsi_write(dsi, VID_HLINE_TIME, lbcc);
+
+	// set vsa
+	dsi_write(dsi, VID_VSA_LINES, vsa);
+	// set vbp
+	dsi_write(dsi, VID_VBP_LINES, vbp);
+	// set vfp
+	dsi_write(dsi, VID_VFP_LINES, vfp);
+	// set vline
+	dsi_write(dsi, VID_VACTIVE_LINES, vact);
+}
+
+void canaan_dsi_lpdt_init(struct canaan_dsi *dsi, struct drm_display_mode *mode)
+{
+	// set lpdt div 
+	dsi_write(dsi, CLKMGR_CFG, 0x108);
+	// set vcid
+	dsi_write(dsi, GEN_VCID, 0x303);
+	// stt dpi tinging
+	canaan_dsi_set_dpi_timing(dsi, mode);
+	/*
+	 * TODO dw drv improvements
+	 * compute high speed transmission counter timeout according
+	 * to the timeout clock division (TO_CLK_DIVISION) and byte lane...
+	 */
+	// dsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));
+	// /*
+	//  * TODO dw drv improvements
+	//  * the Bus-Turn-Around Timeout Counter should be computed
+	//  * according to byte lane...
+	//  */
+	// dsi_write(dsi, DSI_BTA_TO_CNT, 0xd00);
+
+	dsi_write(dsi, MODE_CFG, 0x1);
+	dsi_write(dsi, VID_MODE_CFG, 0xbf02);
+	dsi_write(dsi, CMD_MODE_CFG, 0x10f7f01);
+	dsi_write(dsi, PCKHDL_CFG, 0x1c);
+	dsi_write(dsi, 0x4, 0x1);
+}
+
+
+static void canaan_mipi_dsi_set_dsi_enable(struct canaan_dsi *dsi)
+{
+	dsi_write(dsi, DPI_COLOR_CODING, 0x105);
+	dsi_write(dsi, 0x9c, 0x320068);
+	dsi_write(dsi, 0x98, 0x2e0080);
+	dsi_write(dsi, 0xc4, 0xffffffff);
+	dsi_write(dsi, 0xc8, 0xffffffff);
+	dsi_write(dsi, MODE_CFG, 0x0);
+	dsi_write(dsi, CMD_MODE_CFG, 0x0);
+	dsi_write(dsi, LPCLK_CTRL, 0x3);
+	dsi_write(dsi, LPCLK_CTRL, 0x1);
+
+}
+
+static void canaan_mipi_dsi_set_test_mode(struct canaan_dsi *dsi)
+{
+	uint32_t reg = 0;
+    //1. set MODE_CFG register to enable Video mode
+
+    //2. Configure the DPI_COLOR_CODING register.
+
+    //3. Configure the frame using the registers
+
+    //4. Configure the pattern generation mode
+    reg = dsi_read(dsi, VID_MODE_CFG);
+    reg = (reg & ~(BIT_MASK(20))) | (1 << 20);
+    reg = (reg & ~(BIT_MASK(24))) | (1 << 24);
+    reg = (reg & ~(BIT_MASK(16))) | (1 << 16);
+	dsi_write(dsi, VID_MODE_CFG, reg);
+}
+
+
+
+static void canaan_dsi_encoder_enable(struct drm_encoder *encoder)
+{
+	struct canaan_dsi *dsi = encoder_to_canaan_dsi(encoder);
+	struct drm_display_mode *adjusted_mode = &encoder->crtc->state->adjusted_mode;
+	struct mipi_dsi_device *device = dsi->device;	
+	int dsi_test_en = 0;
+
+	DRM_DEBUG_DRIVER("Enabling DSI output\n");
+
+	printk("canaan_dsi_encoder_enable ------------------- %d \n", adjusted_mode->clock);
+	switch(adjusted_mode->clock)
+	{
+		case 74250:
+			// 74.25M
+			k230_dsi_config_4lan_phy(dsi, TXPHY_445_5_M, TXPHY_445_5_N, TXPHY_445_5_VOC, TXPHY_445_5_HS_FREQ);
+			// set clk todo
+			dsi->phy_freq = 445500;
+			dsi->clk_freq = 74250;
+			break;
+		case 148500:
+			// 144.5M
+			k230_dsi_config_4lan_phy(dsi, TXPHY_891_M, TXPHY_891_N, TXPHY_891_VOC, TXPHY_891_HS_FREQ);
+			// set clk todo
+
+			dsi->phy_freq = 890666;
+			dsi->clk_freq = 148500;
+			break;
+		default:
+			printk("mipi clk not support \n");
+			break;
+	}
+	// set dsi lan num
+	canaan_dsi_set_lan_num(dsi, device->lanes);
+	// set lpdt 
+	canaan_dsi_lpdt_init(dsi, adjusted_mode);
+
+	/*
+	 * Enable the DSI block.
+	 */
+
+	printk("panel ptr: %p\n", dsi->panel);
+	if (dsi->panel)
+		drm_panel_prepare(dsi->panel);
+
+	/*
+	 * FIXME: This should be moved after the switch to HS mode.
+	 *
+	 * Unfortunately, once in HS mode, it seems like we're not
+	 * able to send DCS commands anymore, which would prevent any
+	 * panel to send any DCS command as part as their enable
+	 * method, which is quite common.
+	 *
+	 * I haven't seen any artifact due to that sub-optimal
+	 * ordering on the panels I've tested it with, so I guess this
+	 * will do for now, until that IP is better understood.
+	 */
+	if (dsi->panel)
+		drm_panel_enable(dsi->panel);
+
+	//dsi enable 
+	canaan_mipi_dsi_set_dsi_enable(dsi);
+
+	if(dsi_test_en == 1)
+		canaan_mipi_dsi_set_test_mode(dsi);
+
+	printk("%s done\n", __func__);
+}
+
+static void canaan_dsi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct canaan_dsi *dsi = encoder_to_canaan_dsi(encoder);
+
+	DRM_DEBUG_DRIVER("Disabling DSI output\n");
+
+	if (dsi->panel) {
+		drm_panel_disable(dsi->panel);
+		drm_panel_unprepare(dsi->panel);
+	}
+}
+
+static int canaan_dsi_get_modes(struct drm_connector *connector)
+{
+	struct canaan_dsi *dsi = connector_to_canaan_dsi(connector);
+
+	return drm_panel_get_modes(dsi->panel, connector);
+}
+
+static const struct drm_connector_helper_funcs canaan_dsi_connector_helper_funcs = {
+	.get_modes	= canaan_dsi_get_modes,
+};
+
+static enum drm_connector_status
+canaan_dsi_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct canaan_dsi *dsi = connector_to_canaan_dsi(connector);
+
+	return dsi->panel ? connector_status_connected :
+			    connector_status_disconnected;
+}
+
+static const struct drm_connector_funcs canaan_dsi_connector_funcs = {
+	.detect			= canaan_dsi_connector_detect,
+	.fill_modes		= drm_helper_probe_single_connector_modes,
+	.destroy		= drm_connector_cleanup,
+	.reset			= drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_connector_destroy_state,
+};
+
+static const struct drm_encoder_helper_funcs canaan_dsi_enc_helper_funcs = {
+	.disable	= canaan_dsi_encoder_disable,
+	.enable		= canaan_dsi_encoder_enable,
+};
+
+static int canaan_dsi_attach(struct mipi_dsi_host *host,
+			    struct mipi_dsi_device *device)
+{
+	struct canaan_dsi *dsi = host_to_canaan_dsi(host);
+	struct drm_panel *panel = of_drm_find_panel(device->dev.of_node);
+
+	if (IS_ERR(panel))
+		return PTR_ERR(panel);
+	else
+		dsi->connector.status = connector_status_connected;
+
+	dsi->panel = panel;
+	dsi->device = device;
+
+	dev_info(host->dev, "Attached device %s\n", device->name);
+
+	return 0;
+}
+
+static int canaan_dsi_detach(struct mipi_dsi_host *host,
+			    struct mipi_dsi_device *device)
+{
+	struct canaan_dsi *dsi = host_to_canaan_dsi(host);
+
+	dsi->panel = NULL;
+	dsi->device = NULL;
+
+	return 0;
+}
+
+static ssize_t canaan_dsi_transfer(struct mipi_dsi_host *host,
+				  const struct mipi_dsi_msg *msg)
+{
+	struct canaan_dsi *dsi = host_to_canaan_dsi(host);
+	int ret;
+
+	ret = canaan_dsi_inst_wait_for_completion(dsi);
+	if (ret < 0)
+		canaan_dsi_inst_abort(dsi);
+
+	switch (msg->type) {
+		case MIPI_DSI_DCS_SHORT_WRITE:
+			ret = canaan_dsi_dcs_write_short(dsi, msg);
+			break;
+		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		case MIPI_DSI_DCS_LONG_WRITE:
+		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+			ret = canaan_dsi_dcs_write_long(dsi, msg);
+			break;
+
+		case MIPI_DSI_DCS_READ:
+			if (msg->rx_len == 1) {
+				ret = canaan_dsi_dcs_read(dsi, msg);
+				break;
+			}
+			fallthrough;
+		default:
+			ret = -EINVAL;
+	}
+	return ret;
+}
+
+static const struct mipi_dsi_host_ops canaan_dsi_host_ops = {
+	.attach		= canaan_dsi_attach,
+	.detach		= canaan_dsi_detach,
+	.transfer	= canaan_dsi_transfer,
+};
+
+
+static int canaan_dsi_bind(struct device *dev, struct device *master,
+			 void *data)
+{
+	struct drm_device *drm = data;
+	struct canaan_dsi *dsi = dev_get_drvdata(dev);
+	int ret;
+
+	drm_encoder_helper_add(&dsi->encoder,
+			       &canaan_dsi_enc_helper_funcs);
+	ret = drm_simple_encoder_init(drm, &dsi->encoder,
+				      DRM_MODE_ENCODER_DSI);
+	if (ret) {
+		dev_err(dsi->dev, "Couldn't initialise the DSI encoder\n");
+		return ret;
+	}
+	dsi->encoder.possible_crtcs = BIT(0);
+
+	drm_connector_helper_add(&dsi->connector,
+				 &canaan_dsi_connector_helper_funcs);
+	ret = drm_connector_init(drm, &dsi->connector,
+				 &canaan_dsi_connector_funcs,
+				 DRM_MODE_CONNECTOR_DSI);
+	if (ret) {
+		dev_err(dsi->dev,
+			"Couldn't initialise the DSI connector\n");
+		goto err_cleanup_connector;
+	}
+
+	drm_connector_attach_encoder(&dsi->connector, &dsi->encoder);
+
+	dsi->drm = drm;
+
+	return 0;
+
+err_cleanup_connector:
+	drm_encoder_cleanup(&dsi->encoder);
+	return ret;
+}
+
+static void canaan_dsi_unbind(struct device *dev, struct device *master,
+			    void *data)
+{
+	struct canaan_dsi *dsi = dev_get_drvdata(dev);
+
+	dsi->drm = NULL;
+}
+
+static const struct component_ops canaan_dsi_ops = {
+	.bind	= canaan_dsi_bind,
+	.unbind	= canaan_dsi_unbind,
+};
+
+static int canaan_dsi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct canaan_dsi *dsi;
+	struct resource *res;
+	int ret;
+
+	dev_info(&pdev->dev, "probe\n");
+	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
+	if (!dsi)
+		return -ENOMEM;
+	dev_set_drvdata(dev, dsi);
+	dsi->dev = dev;
+	dsi->host.ops = &canaan_dsi_host_ops;
+	dsi->host.dev = dev;
+
+	// DSI Device Tree Read..
+	// get dsi base addr 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    dsi->base = devm_ioremap_resource(dev, res);
+    if (IS_ERR(dsi->base)) {
+        dev_err(dev, "Couldn't map the DSI encoder registers\n");
+        return PTR_ERR(dsi->base);
+    }
+
+	ret = mipi_dsi_host_register(&dsi->host);
+	if (ret) {
+		dev_err(dev, "Couldn't register MIPI-DSI host\n");
+		goto err_unprotect_clk;
+	}
+
+	ret = component_add(&pdev->dev, &canaan_dsi_ops);
+	if (ret) {
+		dev_err(dev, "Couldn't register our component\n");
+		goto err_remove_dsi_host;
+	}
+
+	return 0;
+
+err_remove_dsi_host:
+	mipi_dsi_host_unregister(&dsi->host);
+err_unprotect_clk:
+	clk_rate_exclusive_put(dsi->mod_clk);
+// err_attach_clk:
+// 	if (!IS_ERR(dsi->bus_clk))
+// 		regmap_mmio_detach_clk(dsi->regs);
+	return ret;
+}
+
+static int canaan_dsi_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id canaan_dsi_of_table[] = {
+	{ .compatible = "canaan,k230-mipi-dsi" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, canaan_dsi_of_table);
+
+struct platform_driver canaan_dsi_driver = {
+	.probe		= canaan_dsi_probe,
+	.remove		= canaan_dsi_remove,
+	.driver		= {
+		.name		= "canaan-mipi-dsi",
+		.of_match_table	= canaan_dsi_of_table,
+	},
+};
+
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("Canaan K230 DSI Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/canaan/canaan_dsi.h b/drivers/gpu/drm/canaan/canaan_dsi.h
new file mode 100755
index 000000000..4ba88e98b
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_dsi.h
@@ -0,0 +1,54 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef _CANAAN_DSI_H_
+#define _CANAAN_DSI_H_
+
+#include <drm/drm_connector.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_mipi_dsi.h>
+
+struct canaan_dsi {
+	struct drm_connector	connector;
+	struct drm_encoder	encoder;
+	struct mipi_dsi_host	host;
+
+	struct clk		*bus_clk;
+	struct clk		*mod_clk;
+	struct regmap		*regs;
+	struct regulator	*regulator;
+	struct reset_control	*reset;
+	struct phy		*dphy;
+
+	struct device		*dev;
+	struct mipi_dsi_device	*device;
+	struct drm_device	*drm;
+	struct drm_panel	*panel;
+
+	void __iomem *base;
+	u32 phy_freq;
+	u32 clk_freq;
+};
+
+static inline struct canaan_dsi *host_to_canaan_dsi(struct mipi_dsi_host *host)
+{
+	return container_of(host, struct canaan_dsi, host);
+};
+
+static inline struct canaan_dsi *connector_to_canaan_dsi(struct drm_connector *connector)
+{
+	return container_of(connector, struct canaan_dsi, connector);
+};
+
+static inline struct canaan_dsi *encoder_to_canaan_dsi(const struct drm_encoder *encoder)
+{
+	return container_of(encoder, struct canaan_dsi, encoder);
+};
+
+void k230_dsi_config_4lan_phy(struct canaan_dsi *dsi, uint32_t m, uint32_t n, uint8_t vco, uint8_t hsfreq);
+
+#endif /* _CANAAN_DSI_H_ */
diff --git a/drivers/gpu/drm/canaan/canaan_phy.c b/drivers/gpu/drm/canaan/canaan_phy.c
new file mode 100755
index 000000000..88f4f58fe
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_phy.c
@@ -0,0 +1,241 @@
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/crc-ccitt.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy-mipi-dphy.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+#include "canaan_dsi.h"
+#include "linux/export.h"
+#include <video/mipi_display.h>
+
+
+#define TXDPHY_PLL_CFG1         0x10
+#define TXDPHY_PLL_CFG0         0x08
+#define PHY_TST_CTRL0           0xb4
+#define PHY_TST_CTRL1           0xb8
+#define TXDPHY_CFG1             0x4
+#define PHY_RSTZ                0xa0
+#define TXDPHY_CFG0             0x0
+#define PHY_STATUS              (0xb0)
+#define LPCLK_CTRL              (0x94)
+
+static void k230_dsi_write_phy_reg(struct canaan_dsi *dsi, uint8_t addr, uint8_t val)
+{
+    uint32_t reg = 0;
+
+    reg = 0x10000 + addr;
+    writel(reg, PHY_TST_CTRL1 + dsi->base);
+    writel(0x2, PHY_TST_CTRL0 + dsi->base);
+    writel(0x0, PHY_TST_CTRL0 + dsi->base);
+
+    reg = val;
+    writel(reg, PHY_TST_CTRL1 + dsi->base);
+    writel(0x2, PHY_TST_CTRL0 + dsi->base);
+    writel(0x0, PHY_TST_CTRL0 + dsi->base);
+}
+
+static void k230_dsi_phy_pll_config(struct canaan_dsi *dsi, uint32_t m, uint32_t n, uint8_t vco)
+{
+    uint32_t reg = 0;
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(BIT_MASK(9))) | (1 << 9);             // shadow_clear field
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(BIT_MASK(9))) | (0 << 9);            // shadow_clear field
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(GENMASK(1, 0))) | (0x1 << 0);            // clksel
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG0);         // TODO case by case
+    reg = (reg & ~(GENMASK(26, 17))) | (m << 17);           // M=m+2   M=125
+    reg = (reg & ~(GENMASK(30, 27))) | (n << 27);           // N=n+1   N=6
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG0);         // expect fout = 125 = (1M/4N)*24;  m=125,n=6
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(GENMASK(16, 11))) | (vco << 11);         // vco_cntrl
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+    reg = (reg & ~(GENMASK(6, 0))) | (0x10 << 0);             // cpbias_cntrl
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+    reg = (reg & ~(GENMASK(9, 8))) | (0x00 << 8);             // gmp_cntrl
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+    reg = (reg & ~(GENMASK(16, 11))) | (0x00 << 11);             // int_cntrl
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG0);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(GENMASK(8, 3))) | (0x8 << 3);         // prop_cntrl
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+    k230_dsi_write_phy_reg(dsi, 0x14, 0x2);    // pll1_th1
+    k230_dsi_write_phy_reg(dsi, 0x15, 0x60);    // pll1_th2
+    k230_dsi_write_phy_reg(dsi, 0x16, 0x3);    // pll1_th3
+    k230_dsi_write_phy_reg(dsi, 0x1D, 0x1);    // pll_lock_sel
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+    reg = (reg & ~(BIT_MASK(10))) | (1 << 10);
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+    msleep(1);
+
+    reg = (reg & ~(BIT_MASK(10))) | (0 << 10);
+    writel(reg, dsi->base + 0x400 + TXDPHY_PLL_CFG1);
+
+}
+
+static void k230_dsi_phy0_config(struct canaan_dsi *dsi, uint32_t m, uint32_t n, uint8_t vco, uint8_t hsfreq)
+{
+    uint32_t reg = 0;
+
+    // select phy0
+    writel(0x0, dsi->base + 0x400 + TXDPHY_CFG1);
+    // set rstz
+    writel(0xc, dsi->base + PHY_RSTZ);
+    // Set test clr to 1
+    writel(0x1, dsi->base + PHY_TST_CTRL0);
+    // Set test clr to 0
+    writel(0x0, dsi->base + PHY_TST_CTRL0);
+    // set mastermacro=1, prototyping_env =1 ??
+    k230_dsi_write_phy_reg(dsi, 0x0c, 0x03);
+    //set hsfreqrange
+    // k230_dsi_write_phy_reg(0x44, 0x96);             // set 445.5  hsfreqrange = 0010110  ??为什么补了个高位为1 啊 （b10010110）
+    k230_dsi_write_phy_reg(dsi, 0x44, hsfreq);             // set 445.5  hsfreqrange = 0010110  ??为什么补了个高位为1 啊 （b10010110）
+    // for < 1.5Gbps data rate set Slew
+    k230_dsi_write_phy_reg(dsi, 0xa0, 0x40);           // set Slew rate vs DDL sr_range      *TODO case by case
+    k230_dsi_write_phy_reg(dsi, 0xa4, 0x11);           // set Slew sr_osc_freq_target[6:0]   *TODO case by case
+    k230_dsi_write_phy_reg(dsi, 0xa4, 0x85);           // set Slew sr_osc_freq_target[11:7]  *TODO case by case
+    k230_dsi_write_phy_reg(dsi, 0xa3, 0x1);           // enable Slew rate calibration  (sr_sel_tester)
+
+    k230_dsi_write_phy_reg(dsi, 0x1f, 0x1);               // mpll_prog[0] = 1'b1
+    k230_dsi_write_phy_reg(dsi, 0x4a, 0x40);               // prg_on_lane0 = 1'b1
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_CFG0);
+    reg = (reg & ~(GENMASK(7, 2))) | (0x28 << 2);            //phy0 cfgclkfreqrange     6'b101000;
+    reg = (reg & ~(GENMASK(13, 8))) | (0x28 << 8);          //phy1 cfgclkfreqrange      6'b101000;
+    writel(reg, dsi->base + 0x400 + TXDPHY_CFG0);
+
+    // config pll
+    // k230_dsi_phy_pll_config(295, 15, 0x17);                  // 222.75 M   phy clk = pll x 2
+    k230_dsi_phy_pll_config(dsi, m, n, vco);                  // 222.75 M   phy clk = pll x 2
+
+    writel(0x28a0, dsi->base + 0x400 + TXDPHY_CFG0);
+    writel(0xc, dsi->base + PHY_RSTZ);
+}
+
+
+void k230_dsi_phy1_config(struct canaan_dsi *dsi, uint8_t hsfreq)
+{
+    uint32_t reg = 0;
+
+    // select1
+    writel(0x400000, dsi->base + 0x400 + TXDPHY_CFG1);
+
+    // printf("0x400000 is %x \n", readl(dsi->base + 0x400 + TXDPHY_CFG1));
+
+    writel(0x1, dsi->base + PHY_TST_CTRL0);
+    msleep(1);
+    writel(0x0, dsi->base + PHY_TST_CTRL0);
+
+    // SET TEST CLR TO LOW
+    k230_dsi_write_phy_reg(dsi, 0xc, 0x0);
+
+    // select1
+    writel(0x400000, dsi->base + 0x400 + TXDPHY_CFG1);
+
+
+    //set hsfreqrange 445.5Mbps
+    // k230_dsi_write_phy_reg(0x44, 0x96);         // set 445.5  hsfreqrange = 0010110  ??为什么补了个高位为1 啊 （b10010110）
+    k230_dsi_write_phy_reg(dsi, 0x44, hsfreq);         // set 445.5  hsfreqrange = 0010110  ??为什么补了个高位为1 啊 （b10010110）
+
+    // try slave phy hs clk lane
+    k230_dsi_write_phy_reg(dsi, 0x30, 0xff);
+
+    // for < 1.5Gbps data rate set Slew
+    k230_dsi_write_phy_reg(dsi, 0xa0, 0x40);           // set Slew rate vs DDL sr_range      *TODO case by cas
+
+    k230_dsi_write_phy_reg(dsi, 0xa4, 0x11);           // set Slew sr_osc_freq_target[6:0]   *TODO case by case
+
+    k230_dsi_write_phy_reg(dsi, 0xa4, 0x85);           // set Slew sr_osc_freq_target[11:7]  *TODO case by case
+    k230_dsi_write_phy_reg(dsi, 0xa3, 0x1);           // enable Slew rate calibration  (sr_sel_tester)
+    k230_dsi_write_phy_reg(dsi, 0x1f, 0x1);               // mpll_prog[0] = 1'b1
+
+    k230_dsi_write_phy_reg(dsi, 0x4a, 0x40);               // prg_on_lane0 = 1'b1
+
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_CFG0);
+    reg = (reg & ~(GENMASK(7, 2))) | (0x28 << 2);            //phy0 cfgclkfreqrange     6'b101000;
+    reg = (reg & ~(GENMASK(13, 8))) | (0x28 << 8);          //phy1 cfgclkfreqrange      6'b101000;
+    writel(reg, dsi->base + 0x400 + TXDPHY_CFG0);
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_CFG0);
+    reg = (reg & ~(BIT_MASK(1))) | (0 << 1);
+    writel(reg, dsi->base + 0x400 + TXDPHY_CFG0);            //phy1 basedir
+
+    writel(0x4, dsi->base + PHY_RSTZ);               //phy enableclk
+    writel(0xd, dsi->base + PHY_RSTZ);               // redundant
+    writel(0xf, dsi->base + PHY_RSTZ);
+
+    k230_dsi_write_phy_reg(dsi, 0x3, 0x80);              // monitor phy fsm
+    unsigned count = 0;
+    while (readl(dsi->base + PHY_TST_CTRL1) != 0x580)  //0x580
+    {
+        k230_dsi_write_phy_reg(dsi, 0x03, 0x80);
+        msleep(1);
+        count += 1;
+        if (count >= 1000) {
+            printk("%s warning break\n", __func__);
+            break;
+        }
+    }
+
+    // printf("phy1 config done \n");
+}
+
+void k230_dsi_config_4lan_phy(struct canaan_dsi *dsi, uint32_t m, uint32_t n, uint8_t vco, uint8_t hsfreq)
+{
+    uint32_t reg = 0;
+
+    k230_dsi_phy0_config(dsi, m, n, vco, hsfreq);
+    k230_dsi_phy1_config(dsi, hsfreq);
+
+
+    reg = readl(dsi->base + 0x400 + TXDPHY_CFG1); // rdata = 0x0
+    writel(0x0, dsi->base + 0x400 + TXDPHY_CFG1);
+    writel(0xd, dsi->base + PHY_RSTZ);
+    writel(0xf, dsi->base + PHY_RSTZ);
+
+    while (readl(dsi->base + PHY_STATUS) != 0x1fbd);
+
+    msleep(1);
+    /* To postpone HS request,  for MIPI spec: First STOP_STATE time should be greater than T_INIT time at least 100us */
+    writel(0x1, dsi->base + LPCLK_CTRL);
+
+    //-------- display_dut_cfg_seq_dsi::wait_for_PHY1_PWRUP() -------//
+    // printf("=== wait_for_PHY1_PWRUP() begin=== \n");
+    reg = readl(dsi->base + 0x400 + TXDPHY_CFG1); // rdata = 0x0
+    writel(0x400000, dsi->base + 0x400 + TXDPHY_CFG1);
+
+    while (readl(dsi->base + PHY_STATUS) != 0x1fbd);
+
+    reg = readl(dsi->base + PHY_STATUS); // rdata = 0x1fbd
+
+}
\ No newline at end of file
diff --git a/drivers/gpu/drm/canaan/canaan_plane.c b/drivers/gpu/drm/canaan/canaan_plane.c
new file mode 100755
index 000000000..5c6c9695a
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_plane.c
@@ -0,0 +1,136 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_of.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+#include <drm/drm_irq.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#endif
+#include <drm/drm_vblank.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_print.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
+
+#include "canaan_vo.h"
+#include "canaan_crtc.h"
+#include "canaan_plane.h"
+
+static int canaan_plane_atomic_check(struct drm_plane *plane,
+                                struct drm_atomic_state *state)
+{
+    struct drm_plane_state* plane_state = drm_atomic_get_new_plane_state(state, plane);
+    struct canaan_plane *canaan_plane = to_canaan_plane(plane);
+    struct canaan_vo *vo = canaan_plane->vo;
+
+    if (!plane_state->crtc || !plane_state->fb) {
+        DRM_DEBUG_DRIVER("crtc or fb NULL \n");
+        return 0;
+    }
+
+    DRM_DEBUG_DRIVER("Check plane:%d\n", plane->base.id);
+    DRM_DEBUG_DRIVER("(%d,%d)@(%d,%d) -> (%d,%d)@(%d,%d)\n",
+                plane_state->src_w >> 16, plane_state->src_h >> 16,
+                plane_state->src_x >> 16, plane_state->src_y >> 16,
+                plane_state->crtc_w, plane_state->crtc_h,
+                plane_state->crtc_x, plane_state->crtc_y);
+
+    return canaan_vo_check_plane(vo, canaan_plane, plane_state);
+}
+
+static void canaan_plane_atomic_update(struct drm_plane *plane,
+                                struct drm_atomic_state *state)
+{
+    struct drm_plane_state *plane_state = plane->state;
+    struct canaan_plane *canaan_plane = to_canaan_plane(plane);
+    struct canaan_vo *vo = canaan_plane->vo;
+
+    if (!plane_state->crtc || !plane_state->fb) {
+        DRM_DEBUG_DRIVER("crtc or fb NULL \n");
+        return;
+    }
+
+    DRM_DEBUG_DRIVER("Update plane:%d\n", plane->base.id);
+    canaan_vo_update_plane(vo, canaan_plane, plane_state);
+}
+
+static void canaan_plane_atomic_disable(struct drm_plane *plane,
+                                struct drm_atomic_state *state)
+{
+    struct canaan_plane *canaan_plane = to_canaan_plane(plane);
+    struct canaan_vo *vo = canaan_plane->vo;
+
+    DRM_DEBUG_DRIVER("Disable plane:%d\n", plane->base.id);
+    canaan_vo_disable_plane(vo, canaan_plane);
+}
+
+static const struct drm_plane_funcs canaan_plane_funcs = {
+    .reset = drm_atomic_helper_plane_reset,
+    .destroy = drm_plane_cleanup,
+    .update_plane = drm_atomic_helper_update_plane,
+    .disable_plane = drm_atomic_helper_disable_plane,
+    .atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static const struct drm_plane_helper_funcs canaan_plane_helper_funcs = {
+    .atomic_check = canaan_plane_atomic_check,
+    .atomic_update = canaan_plane_atomic_update,
+    .atomic_disable = canaan_plane_atomic_disable,
+};
+
+struct canaan_plane *canaan_plane_create(struct drm_device *drm_dev,
+                                    struct canaan_plane_config *config,
+                                    struct canaan_vo *vo)
+{
+    int ret = 0;
+    struct canaan_plane *canaan_plane = NULL;
+    struct drm_plane *plane = NULL;
+    struct device *dev = vo->dev;
+
+    canaan_plane = devm_kzalloc(dev, sizeof(*canaan_plane), GFP_KERNEL);
+    if (!canaan_plane)
+        return ERR_PTR(-ENOMEM);
+    plane = &canaan_plane->base;
+
+    ret = drm_universal_plane_init(drm_dev, plane, config->possible_crtcs,
+                                &canaan_plane_funcs, config->formats, config->num_formats,
+                                NULL, config->plane_type, NULL);
+    if (ret) {
+        DRM_DEV_ERROR(dev, "Failed to init Plane \n");
+        return ERR_PTR(ret);
+    }
+
+    drm_plane_helper_add(plane, &canaan_plane_helper_funcs);
+    canaan_plane->id        = config->id;
+    canaan_plane->config    = config;
+    canaan_plane->vo        = vo;
+    DRM_DEBUG_DRIVER("Create plane:%d\n", plane->base.id);
+
+    return canaan_plane;
+}
+
diff --git a/drivers/gpu/drm/canaan/canaan_plane.h b/drivers/gpu/drm/canaan/canaan_plane.h
new file mode 100755
index 000000000..391d9a47d
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_plane.h
@@ -0,0 +1,40 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_PLANE_H__
+#define __CANAAN_PLANE_H__
+
+struct canaan_plane_config {
+    char        *name;
+    uint32_t    id;
+    uint32_t    possible_crtcs;
+    uint32_t    num_formats;
+    const uint32_t      *formats;
+    enum drm_plane_type plane_type;
+
+    uint32_t    plane_offset;
+    uint32_t    plane_enable_bit;
+    uint32_t    xctl_reg_offset;
+    uint32_t    yctl_reg_offset;
+};
+
+struct canaan_plane {
+    struct drm_plane    base;
+    struct canaan_vo    *vo;
+    struct canaan_plane_config  *config;
+    uint32_t    id;
+};
+
+static inline struct canaan_plane *to_canaan_plane(struct drm_plane *plane)
+{
+    return container_of(plane, struct canaan_plane, base);
+}
+
+struct canaan_plane *canaan_plane_create(struct drm_device *drm_dev,
+                                    struct canaan_plane_config *config,
+                                    struct canaan_vo *vo);
+#endif /* __CANAAN_PLANE_H__ */
diff --git a/drivers/gpu/drm/canaan/canaan_vo.c b/drivers/gpu/drm/canaan/canaan_vo.c
new file mode 100755
index 000000000..9f643f4ff
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_vo.c
@@ -0,0 +1,646 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_of.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+#include <drm/drm_irq.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#else
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_gem_dma_helper.h>
+#include <drm/drm_fb_dma_helper.h>
+#endif
+#include <drm/drm_vblank.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_print.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
+
+#include "canaan_vo.h"
+#include "canaan_vo_regs.h"
+#include "canaan_vo_table.h"
+#include "canaan_crtc.h"
+#include "canaan_plane.h"
+
+
+
+static inline void canaan_vo_write(struct canaan_vo *vo, u32 reg, u32 val)
+{
+	writel(val, vo->reg_base + reg);
+}
+
+static inline u32 canaan_vo_read(struct canaan_vo *vo, u32 reg)
+{
+	return readl(vo->reg_base + reg);
+}
+
+
+static void canaan_vo_update_video(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_display_mode *adj_mode)
+{
+    uint32_t reg_val = 0x00;
+    struct drm_plane_state *plane_state = canaan_plane->base.state;
+    struct drm_framebuffer *fb = plane_state->fb;
+    struct drm_gem_dma_object *cma_obj = drm_fb_dma_get_gem_obj(fb, 0);
+    struct canaan_plane_config *config = canaan_plane->config;
+    uint32_t plane_offset = config->plane_offset;
+    uint32_t plane_enable_bit = config->plane_enable_bit;
+    uint32_t xctl_reg_offset = config->xctl_reg_offset;
+    uint32_t yctl_reg_offset = config->yctl_reg_offset;
+    uint32_t actual_w, start_w, offset_w;
+    uint32_t actual_h, start_h, offset_h;
+    uint32_t y_addr, uv_addr;
+    uint32_t stride = 0x00;
+    uint32_t disp_en = 0x00;
+
+    switch (fb->format->format) {
+    case DRM_FORMAT_NV12:
+        reg_val = 1 + (1 << 8) + (1 << 12) + (3 << 16) + (0 << 28);
+        break;
+    case DRM_FORMAT_NV21:
+        reg_val = 1 + (1 << 8) + (1 << 12) + (2 << 16) + (0 << 28);
+        break;
+    case DRM_FORMAT_NV16:
+        reg_val = 1 + (1 << 4) + (1 << 12) + (3 << 16) + (0 << 28);
+        break;
+    case DRM_FORMAT_NV61:
+        reg_val = 1 + (1 << 4) + (1 << 12) + (2 << 16) + (0 << 28);
+        break;
+    default:
+        DRM_DEV_ERROR(vo->dev, "Invalid pixel format %d\n", fb->format->format);
+        return;
+    }
+    writel(reg_val, vo->reg_base + plane_offset + VO_LAYER2_3_CTL_REG_OFFSET);
+
+    actual_w = plane_state->src_w >> 16;
+    actual_h = plane_state->src_h >> 16;
+    reg_val = (actual_w - 1) | (actual_h << 16);
+    writel(reg_val, vo->reg_base + plane_offset + VO_LAYER2_3_ACT_SIZE_REG_OFFSET);
+
+    offset_w = plane_state->crtc_x;
+    start_w = readl(vo->reg_base + VO_DISP_XZONE_CTL) & 0x1fff;
+    reg_val = ((start_w + offset_w + actual_w -1) << 16) + (start_w + offset_w);
+    writel(reg_val, vo->reg_base + xctl_reg_offset);
+
+    offset_h = plane_state->crtc_y;
+    start_h = readl(vo->reg_base + VO_DISP_YZONE_CTL) & 0x1fff;
+    reg_val = ((start_h + offset_h + actual_h -1) << 16) + (start_h + offset_h);
+    writel(reg_val, vo->reg_base + yctl_reg_offset);
+
+    y_addr = cma_obj->dma_addr;
+    writel(y_addr, vo->reg_base + plane_offset + VO_LAYER2_3_Y_ADDR0_REG_OFFSET);
+    writel(y_addr, vo->reg_base + plane_offset + VO_LAYER2_3_Y_ADDR1_REG_OFFSET);
+
+    uv_addr = cma_obj->dma_addr + fb->offsets[1];
+    writel(uv_addr, vo->reg_base + plane_offset + VO_LAYER2_3_UV_ADDR0_REG_OFFSET);
+    writel(uv_addr, vo->reg_base + plane_offset + VO_LAYER2_3_UV_ADDR1_REG_OFFSET);
+
+    stride = (actual_w/8 - 1) | (actual_h << 16);
+    writel(stride, vo->reg_base + plane_offset + VO_LAYER2_3_STRIDE_REG_OFFSET);
+
+    writel(0x00, vo->reg_base + plane_offset + VO_LAYER2_3_IMG_IN_OFFSET_REG_OFFSET);
+    writel(0x0f, vo->reg_base + plane_offset + VO_LAYER2_3_BLENTH_REG_OFFSET);
+    writel(0x11, vo->reg_base + plane_offset + VO_LAYER2_3_ADDR_SEL_MODE_REG_OFFSET);
+
+    disp_en = readl(vo->reg_base + VO_DISP_ENABLE);
+    disp_en |= 1 << plane_enable_bit;
+    writel(disp_en, vo->reg_base + VO_DISP_ENABLE);
+
+    DRM_DEBUG_DRIVER("VIDEO_CTL_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_LAYER2_3_CTL_REG_OFFSET));
+    DRM_DEBUG_DRIVER("VIDEO_ACT_SIZE_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_LAYER2_3_ACT_SIZE_REG_OFFSET));
+    DRM_DEBUG_DRIVER("VIDEO_Y_ADDR0_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_LAYER2_3_Y_ADDR0_REG_OFFSET));
+    DRM_DEBUG_DRIVER("VIDEO_UV_ADDR0_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_LAYER2_3_UV_ADDR0_REG_OFFSET));
+    DRM_DEBUG_DRIVER("VIDEO_STRIDE_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_LAYER2_3_STRIDE_REG_OFFSET));
+}
+
+static void canaan_vo_update_osd(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_display_mode *adj_mode)
+{
+    uint32_t reg_val = 0x00;
+    struct drm_plane_state *plane_state = canaan_plane->base.state;
+    struct drm_framebuffer *fb = plane_state->fb;
+    struct drm_gem_dma_object *cma_obj = drm_fb_dma_get_gem_obj(fb, 0);
+    struct canaan_plane_config *config = canaan_plane->config;
+    uint32_t plane_offset = config->plane_offset;
+    uint32_t plane_enable_bit = config->plane_enable_bit;
+    uint32_t xctl_reg_offset = config->xctl_reg_offset;
+    uint32_t yctl_reg_offset = config->yctl_reg_offset;
+    uint32_t actual_w, start_w, offset_w;
+    uint32_t actual_h, start_h, offset_h;
+    dma_addr_t paddr = 0x00;
+    uint32_t stride = 0x00;
+    uint32_t disp_en = 0x00;
+
+    switch (fb->format->format) {
+    case DRM_FORMAT_ARGB8888:
+        reg_val = 0x53;
+        break;
+    case DRM_FORMAT_ARGB4444:
+        reg_val = 0x54;
+        break;
+    case DRM_FORMAT_ARGB1555:
+        reg_val = 0x55;
+        break;
+    case DRM_FORMAT_RGB888:
+        reg_val = 0x00;
+        break;
+    case DRM_FORMAT_RGB565:
+        reg_val = 0x02;
+        break;
+    default:
+        DRM_DEV_ERROR(vo->dev, "Invalid pixel format %d\n", fb->format->format);
+        return;
+    }
+    writel(reg_val, vo->reg_base + plane_offset + VO_OSD0_7_INFO_REG_OFFSET);
+
+    actual_w = plane_state->src_w >> 16;
+    actual_h = plane_state->src_h >> 16;
+    reg_val = actual_w | actual_h << 16;
+    writel(reg_val, vo->reg_base + plane_offset + VO_OSD0_7_SIZE_REG_OFFSET);
+
+    offset_w = plane_state->crtc_x;
+    start_w = readl(vo->reg_base + VO_DISP_XZONE_CTL) & 0x1fff;
+    reg_val = ((start_w + offset_w + actual_w -1) << 16) + (start_w + offset_w);
+    writel(reg_val, vo->reg_base + xctl_reg_offset);
+
+    offset_h = plane_state->crtc_y;
+    start_h = readl(vo->reg_base + VO_DISP_YZONE_CTL) & 0x1fff;
+    reg_val = ((start_h + offset_h + actual_h -1) << 16) + (start_h + offset_h);
+    writel(reg_val, vo->reg_base + yctl_reg_offset);
+
+    paddr = cma_obj->dma_addr;
+    writel(paddr, vo->reg_base + plane_offset + VO_OSD0_7_VLU_ADDR0_REG_OFFSET);
+    writel(paddr, vo->reg_base + plane_offset + VO_OSD0_7_ALP_ADDR0_REG_OFFSET);
+    writel(paddr, vo->reg_base + plane_offset + VO_OSD0_7_VLU_ADDR1_REG_OFFSET);
+    writel(paddr, vo->reg_base + plane_offset + VO_OSD0_7_ALP_ADDR1_REG_OFFSET);
+
+    stride = fb->pitches[0]/8;
+    writel(stride, vo->reg_base + plane_offset + VO_OSD0_7_STRIDE_REG_OFFSET);
+
+    writel(0x4F, vo->reg_base + plane_offset + VO_OSD0_7_DMA_CTRL_REG_OFFSET);
+    writel(0x100, vo->reg_base + plane_offset + VO_OSD0_7_ADDR_SEL_MODE_REG_OFFSET);
+
+    disp_en = readl(vo->reg_base + VO_DISP_ENABLE);
+    disp_en |= 1 << plane_enable_bit;
+    writel(disp_en, vo->reg_base + VO_DISP_ENABLE);
+
+    DRM_DEBUG_DRIVER("OSD_INFO_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_OSD0_7_INFO_REG_OFFSET));
+    DRM_DEBUG_DRIVER("OSD_SIZE_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_OSD0_7_SIZE_REG_OFFSET));
+    DRM_DEBUG_DRIVER("OSD_VLU_ADDR0_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_OSD0_7_VLU_ADDR0_REG_OFFSET));
+    DRM_DEBUG_DRIVER("OSD_ALP_ADDR0_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_OSD0_7_ALP_ADDR0_REG_OFFSET));
+    DRM_DEBUG_DRIVER("OSD_STRIDE_REG: 0x%02x\n", readl(vo->reg_base + plane_offset + VO_OSD0_7_STRIDE_REG_OFFSET));
+}
+
+int canaan_vo_check_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_plane_state *plane_state)
+{
+    int ret = 0;
+    struct drm_crtc_state *crtc_state = NULL;
+
+    crtc_state = drm_atomic_get_crtc_state(plane_state->state, plane_state->crtc);
+    if (IS_ERR(crtc_state)) {
+        DRM_DEV_ERROR(vo->dev, "Failed to get crtc_state \n");
+        return PTR_ERR(crtc_state);
+    }
+
+    ret = drm_atomic_helper_check_plane_state(plane_state, crtc_state,
+                                        DRM_PLANE_NO_SCALING,
+                                        DRM_PLANE_NO_SCALING,
+                                        true, true);
+    if (ret) {
+        DRM_DEV_ERROR(vo->dev, "Failed to check plane_state \n");
+        return ret;
+    }
+
+    return 0;
+}
+
+void canaan_vo_update_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_plane_state *plane_state)
+{
+    struct drm_crtc_state *crtc_state = plane_state->crtc->state;
+    struct drm_display_mode *adj_mode = &crtc_state->adjusted_mode;
+
+    if (vo->canaan_plane[0]->id == canaan_plane->id) {
+        canaan_vo_update_video(vo, canaan_plane, adj_mode);
+    } else {
+        canaan_vo_update_osd(vo, canaan_plane, adj_mode);
+    }
+}
+
+void canaan_vo_disable_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane)
+{
+    struct canaan_plane_config *config = canaan_plane->config;
+    uint32_t plane_enable_bit = config->plane_enable_bit;
+    uint32_t disp_en = 0x00;
+
+    disp_en = readl(vo->reg_base + VO_DISP_ENABLE);
+    disp_en &= ~(1 << plane_enable_bit);
+    writel(disp_en, vo->reg_base + VO_DISP_ENABLE);
+}
+
+static irqreturn_t canaan_vo_irq_handler(int irq, void *dev_id)
+{
+    struct canaan_vo *vo = dev_id;
+    struct canaan_crtc *canaan_crtc = vo->canaan_crtc;
+
+    canaan_vo_write(vo, VO_DISP_IRQ_STATUS, 0xffffffff);
+
+    // printk("canaan_vo_irq_handler--------------- \n");
+    if (atomic_read(&vo->vsync_enabled)) {
+        
+        drm_crtc_handle_vblank(&canaan_crtc->base);
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void canaan_vo_set_vtth_intr(struct canaan_vo *vo, bool status, u32 vpos)
+{
+    u32 reg = 0;
+
+    reg = (reg & ~(BIT_MASK(20))) | (status << 20);
+    if (status != 0)
+        reg = (reg & ~(GENMASK(12, 0))) | (vpos << 0);
+
+    canaan_vo_write(vo, VO_DISP_IRQ1_CTL, reg);
+}
+
+int canaan_vo_enable_vblank(struct canaan_vo *vo)
+{
+    atomic_set(&vo->vsync_enabled, 1);
+
+    canaan_vo_set_vtth_intr(vo, 1, vo->vth_line);
+    // canaan_vo_write(vo, VO_REG_LOAD_CTL, 0x11);
+    return 0;
+}
+
+void canaan_vo_disable_vblank(struct canaan_vo *vo)
+{
+    atomic_set(&vo->vsync_enabled, 0);
+
+    canaan_vo_set_vtth_intr(vo, 0, vo->vth_line);
+    // canaan_vo_write(vo, VO_REG_LOAD_CTL, 0x11);
+}
+
+
+static void canaan_vo_init(struct canaan_vo *vo)
+{
+    int i = 0;
+    u32 reg = 0;
+    
+    canaan_vo_write(vo, VO_DMA_SW_CTL, 0x11);
+    canaan_vo_write(vo, VO_DMA_RD_CTL_OUT, 0x88);
+    canaan_vo_write(vo, VO_DMA_ARB_MODE, 0x0);
+
+    for (i = 0; i < 8; i++)
+    {
+        canaan_vo_write(vo,  0x14 + (4 * i), 0x1010101);
+    }
+
+    canaan_vo_write(vo, 0x34, 0x76543210);
+    canaan_vo_write(vo, 0x3c, 0x76543210);
+    canaan_vo_write(vo, 0x44, 0x76543210);
+    canaan_vo_write(vo, VO_DMA_ID_RD_0, 0x76543210);
+
+    canaan_vo_write(vo, 0x38, 0xfedcba98);
+    canaan_vo_write(vo, 0x40, 0xfedcba98);
+    canaan_vo_write(vo, 0x48, 0xfedcba98);
+    canaan_vo_write(vo, 0x50, 0xfedcba98);
+
+    for (i = 0; i < 10; i++)
+    {
+        canaan_vo_write(vo, VO_LAYER0_LINE0_BD_CTL + (4 * i), 0x701);
+    }
+
+    canaan_vo_write(vo, 0x800, 0x701);
+    canaan_vo_write(vo, 0x804, 0x701);
+    canaan_vo_write(vo, 0x808, 0x701);
+    canaan_vo_write(vo, 0x80c, 0x701);
+    canaan_vo_write(vo, 0x810, 0x701);
+
+    canaan_vo_write(vo, VO_DISP_ENABLE, 0x0);
+
+    canaan_vo_write(vo, VO_DISP_MIX_LAYER_GLB_EN, 0x7f);
+    canaan_vo_write(vo, VO_DISP_MIX_LAYER_GLB_ALPHA0, 0xffffffff);
+    canaan_vo_write(vo, VO_DISP_MIX_LAYER_GLB_ALPHA1, 0xffffffff);
+    canaan_vo_write(vo, 0x940, 0xffffffff);
+
+
+    reg = 0 + (1 << 4) + (2 << 8) + (3 << 12);
+    canaan_vo_write(vo, VO_DISP_MIX_SEL, reg);
+
+    reg = 4UL + (5UL << 4) + (6UL << 8) + (7UL << 12) + (8UL << 16) + (9UL << 20) + (10UL << 24) + (11UL << 28);
+    canaan_vo_write(vo, 0x950, reg);
+
+    canaan_vo_write(vo, VO_DISP_YUV2RGB_CTL, 0x1);
+    canaan_vo_write(vo, VO_DISP_CLUT_CTL, 0x0);
+    canaan_vo_write(vo, VO_DISP_DITH_CTL, 0x1);
+    canaan_vo_write(vo, VO_OSD_RGB2YUV_CTL, 0x11111111);
+    canaan_vo_write(vo, VO_DISP_MIX_LAYER_GLB_EN, 0xff);
+
+    //close vo irq
+    canaan_vo_write(vo, VO_DISP_IRQ0_CTL, 0x0);
+    canaan_vo_write(vo, VO_DISP_IRQ1_CTL, 0x0);
+    canaan_vo_write(vo, VO_DISP_IRQ2_CTL, 0x0);
+
+    for (i = 0; i < 64; i++)
+    {
+        canaan_vo_write(vo, VO_VSCALE_BASE + ((i * 2) << 2), V_Coef[i * 2]);
+        canaan_vo_write(vo, VO_VSCALE_BASE + ((i * 2 + 1) << 2), V_Coef[i * 2 + 1]);
+    }
+
+    // init HSCALE
+    for (i = 0; i < 64; i++)
+    {
+        canaan_vo_write(vo, VO_HSCALE_BASE + ((i * 4) << 2), H_Coef[i * 3]);
+        canaan_vo_write(vo, VO_HSCALE_BASE + ((i * 4 + 1) << 2), H_Coef[i * 3 + 1]);
+        canaan_vo_write(vo, VO_HSCALE_BASE + ((i * 4 + 2) << 2), H_Coef[i * 3 + 2]);
+    }
+
+    // // set vline irq
+    // canaan_vo_set_vtth_intr(vo, 1, 11);
+}
+
+static void canaan_vo_set_timing(struct canaan_vo *vo, struct drm_display_mode *mode)
+{
+    u32 htotal, hsa, hbp, hact, vsa, vbp, vfp, vact, vtotal;
+    u32 reg = 0;
+
+	htotal = mode->htotal;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	hact = mode->hdisplay;
+
+	vsa = mode->vsync_end - mode->vsync_start;
+	vbp = mode->vtotal - mode->vsync_end;
+	vact = mode->vdisplay;
+	vfp = mode->vtotal - vsa - vbp - vact;
+    vtotal = mode->vtotal;
+    
+    // 0 - 12 start ; 16 - 28 end
+    reg = (0x2 << 16) + 0x1;
+    canaan_vo_write(vo, VO_DISP_HSYNC_CTL, reg);
+
+    reg = (0x6 << 16) + 0x5;
+    canaan_vo_write(vo, VO_DISP_HSYNC1_CTL, reg);
+
+    reg = (0x5 << 16) + 0x1;
+    canaan_vo_write(vo, VO_DISP_HSYNC2_CTL, reg);
+
+    reg = (0x1 << 16) + 0x1;
+    canaan_vo_write(vo, VO_DISP_VSYNC1_CTL, reg);
+
+    reg = (0x1 << 16) + 0x1;
+    canaan_vo_write(vo, VO_DISP_VSYNC2_CTL, reg);
+
+    reg = (5 + hsa + hbp + 1) + (((hact + (5 + hsa + hbp + 1)) - 1) << 16);
+    canaan_vo_write(vo, VO_DISP_XZONE_CTL, reg);
+
+    // set yzone
+    reg = 0;
+    reg = (vbp + 1) + (((vact + (vbp + 1)) - 1) << 16);
+    canaan_vo_write(vo, VO_DISP_YZONE_CTL, reg);
+
+    // set total size
+    reg = 0;
+    reg = (htotal) + ((vtotal) << 16);
+    canaan_vo_write(vo, VO_DISP_TOTAL_SIZE, reg);
+
+    // set draw 
+    reg = 0;
+    reg = (hact - 1) + ((vact - 1) << 16) + (0x1 << 15);
+    canaan_vo_write(vo, 0x780, reg);            // enalbe remap  0x77f8437
+}
+
+void canaan_vo_enable_crtc(struct canaan_vo *vo, struct canaan_crtc *canaan_crtc, struct drm_display_mode *adjusted_mode)
+{
+    
+    canaan_vo_init(vo);
+    // set timing
+    canaan_vo_set_timing(vo, adjusted_mode);
+    // set background
+    canaan_vo_write(vo, VO_DISP_BACKGROUND, 0xffffff);            // enalbe remap  0x77f8437
+    // enable vo
+    canaan_vo_write(vo, VO_REG_LOAD_CTL, 0x11);
+
+}
+
+void canaan_vo_disable_crtc(struct canaan_vo *vo, struct canaan_crtc *canaan_crtc)
+{
+    // canaan_vo_write(vo, VO_REG_LOAD_CTL, 0x0);
+}
+
+void canaan_vo_flush_config(struct canaan_vo *vo)
+{
+    writel(0x11, vo->reg_base + VO_REG_LOAD_CTL);
+}
+
+static const uint32_t video_plane_formats[] = {
+    DRM_FORMAT_NV12,
+    DRM_FORMAT_NV21,
+    DRM_FORMAT_NV16,
+    DRM_FORMAT_NV61,
+};
+
+static const uint32_t osd_plane_formats[] = {
+    DRM_FORMAT_ARGB8888,
+    DRM_FORMAT_ARGB4444,
+    DRM_FORMAT_ARGB1555,
+    DRM_FORMAT_RGB888,
+    DRM_FORMAT_RGB565,
+};
+
+static struct canaan_plane_config canaan_plane_configurations[CANAAN_PLANE_NUMBER] = {
+    {
+        .id = 0,
+        .name = "video_3",
+        .formats = video_plane_formats,
+        .num_formats = ARRAY_SIZE(video_plane_formats),
+        .plane_type = DRM_PLANE_TYPE_OVERLAY,
+        .plane_offset = VO_LAYER3_OFFSET,
+        .plane_enable_bit = 3,
+        .xctl_reg_offset = VO_DISP_LAYER3_XCTL,
+        .yctl_reg_offset = VO_DISP_LAYER3_YCTL,
+    },
+    {
+        .id = 1,
+        .name = "OSD4",
+        .formats = osd_plane_formats,
+        .num_formats = ARRAY_SIZE(osd_plane_formats),
+        .plane_type = DRM_PLANE_TYPE_PRIMARY,
+        .plane_offset = VO_OSD4_OFFSET,
+        .plane_enable_bit = 8,
+        .xctl_reg_offset = VO_DISP_OSD4_XCTL,
+        .yctl_reg_offset = VO_DISP_OSD4_YCTL,
+    },
+    {
+        .id = 2,
+        .name = "OSD5",
+        .formats = osd_plane_formats,
+        .num_formats = ARRAY_SIZE(osd_plane_formats),
+        .plane_type = DRM_PLANE_TYPE_CURSOR,
+        .plane_offset = VO_OSD5_OFFSET,
+        .plane_enable_bit = 9,
+        .xctl_reg_offset = VO_DISP_OSD5_XCTL,
+        .yctl_reg_offset = VO_DISP_OSD5_YCTL,
+    },
+    {
+        .id = 3,
+        .name = "OSD6",
+        .formats = osd_plane_formats,
+        .num_formats = ARRAY_SIZE(osd_plane_formats),
+        .plane_type = DRM_PLANE_TYPE_OVERLAY,
+        .plane_offset = VO_OSD6_OFFSET,
+        .plane_enable_bit = 10,
+        .xctl_reg_offset = VO_DISP_OSD6_XCTL,
+        .yctl_reg_offset = VO_DISP_OSD6_YCTL,
+    },
+    {
+        .id = 4,
+        .name = "OSD7",
+        .formats = osd_plane_formats,
+        .num_formats = ARRAY_SIZE(osd_plane_formats),
+        .plane_type = DRM_PLANE_TYPE_OVERLAY,
+        .plane_offset = VO_OSD7_OFFSET,
+        .plane_enable_bit = 11,
+        .xctl_reg_offset = VO_DISP_OSD7_XCTL,
+        .yctl_reg_offset = VO_DISP_OSD7_YCTL,
+    },
+};
+
+static int canaan_vo_bind(struct device *dev, struct device *master, void *data)
+{
+    int i = 0;
+    int ret = 0;
+    struct canaan_vo *vo = NULL;
+    struct drm_device *drm_dev = data;
+    struct platform_device *pdev = to_platform_device(dev);
+    struct resource *res = NULL;
+    struct canaan_plane_config *config;
+    struct device_node *np =dev->of_node;
+
+    vo = devm_kzalloc(dev, sizeof(*vo), GFP_KERNEL);
+    if (!vo)
+        return -ENOMEM;
+    vo->dev     = dev;
+    vo->drm_dev = drm_dev;
+    dev_set_drvdata(dev, vo);
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        DRM_DEV_ERROR(dev, "Failed to get register resource \n");
+        return -ENXIO;
+    }
+
+    vo->reg_base = devm_ioremap_resource(dev, res);
+    if (IS_ERR(vo->reg_base)) {
+        DRM_DEV_ERROR(dev, "Failed to map register resource \n");
+        return PTR_ERR(vo->reg_base);
+    }
+
+    of_property_read_u32(np, "backgroud", &vo->backgroud);
+    of_property_read_u32(np, "vth_line", &vo->vth_line);
+
+    printk("vo backgroud color is %x \n", vo->backgroud);
+    printk("vo vth_line line is %x \n", vo->vth_line);
+
+    atomic_set(&vo->vsync_enabled, 0);
+    vo->irq = platform_get_irq(pdev, 0);
+    if (vo->irq < 0) {
+        DRM_DEV_ERROR(dev, "Failed to get vsync irq \n");
+        return vo->irq;
+    }
+
+    ret = devm_request_irq(dev, vo->irq, canaan_vo_irq_handler,
+                    0, dev_name(dev), vo);
+    if (ret) {
+        DRM_DEV_ERROR(dev, "Failed to request vsync irq \n");
+        return ret;
+    }
+
+    for (i = 0; i < CANAAN_PLANE_NUMBER; i ++) {
+        config = &canaan_plane_configurations[i];
+        config->possible_crtcs = 1 << drm_dev->mode_config.num_crtc;
+        vo->canaan_plane[i] = canaan_plane_create(drm_dev, config, vo);
+        if (IS_ERR(vo->canaan_plane[i])) {
+            DRM_DEV_ERROR(dev, "Failed to create canaan_plane \n");
+            return PTR_ERR(vo->canaan_plane[i]);
+        }
+    }
+
+    struct drm_plane *primary   = &vo->canaan_plane[1]->base;
+    struct drm_plane *cursor    = &vo->canaan_plane[2]->base;
+    vo->canaan_crtc = canaan_crtc_create(drm_dev, primary, cursor, vo);
+    if (IS_ERR(vo->canaan_crtc)) {
+        DRM_DEV_ERROR(dev, "Failed to create canaan_crtc \n");
+        return PTR_ERR(vo->canaan_crtc);
+    }
+
+    return 0;
+}
+
+static void canaan_vo_unbind(struct device *dev, struct device *master, void *data)
+{
+
+}
+
+static const struct component_ops canaan_vo_component_ops = {
+    .bind   = canaan_vo_bind,
+    .unbind = canaan_vo_unbind,
+};
+
+static int canaan_vo_probe(struct platform_device *pdev)
+{
+    dev_info(&pdev->dev, "probe\n");
+    return component_add(&pdev->dev, &canaan_vo_component_ops);
+}
+
+static int canaan_vo_remove(struct platform_device *pdev)
+{
+    component_del(&pdev->dev, &canaan_vo_component_ops);
+
+    return 0;
+}
+
+static const struct of_device_id canaan_vo_of_table[] = {
+	{ .compatible = "canaan,k230-vo", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, canaan_vo_of_table);
+
+struct platform_driver canaan_vo_driver = {
+	.probe = canaan_vo_probe,
+	.remove = canaan_vo_remove,
+	.driver = {
+		.name = "canaan-vo",
+		.of_match_table = of_match_ptr(canaan_vo_of_table),
+	},
+};
+
+MODULE_DESCRIPTION("Canaan K230 VO Controller");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/canaan/canaan_vo.h b/drivers/gpu/drm/canaan/canaan_vo.h
new file mode 100755
index 000000000..0e623e02e
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_vo.h
@@ -0,0 +1,40 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_VO_H__
+#define __CANAAN_VO_H__
+
+#define CANAAN_PLANE_NUMBER     5
+
+struct canaan_vo {
+    struct device       *dev;
+    struct drm_device   *drm_dev;
+
+    void __iomem        *reg_base;
+    int                 irq;
+    atomic_t            vsync_enabled;
+
+    struct canaan_crtc  *canaan_crtc;
+    struct canaan_plane *canaan_plane[CANAAN_PLANE_NUMBER];
+
+    u32 backgroud;
+    u32 vth_line;
+};
+
+int canaan_vo_check_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_plane_state *plane_state);
+void canaan_vo_update_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane,
+                    struct drm_plane_state *plane_state);
+void canaan_vo_disable_plane(struct canaan_vo *vo, struct canaan_plane *canaan_plane);
+
+int canaan_vo_enable_vblank(struct canaan_vo *vo);
+void canaan_vo_disable_vblank(struct canaan_vo *vo);
+void canaan_vo_enable_crtc(struct canaan_vo *vo, struct canaan_crtc *canaan_crtc, struct drm_display_mode *adjusted_mode);
+void canaan_vo_disable_crtc(struct canaan_vo *vo, struct canaan_crtc *canaan_crtc);
+void canaan_vo_flush_config(struct canaan_vo *vo);
+
+#endif /* __CANAAN_VO_H__ */
diff --git a/drivers/gpu/drm/canaan/canaan_vo_regs.h b/drivers/gpu/drm/canaan/canaan_vo_regs.h
new file mode 100755
index 000000000..d2b5aa17f
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_vo_regs.h
@@ -0,0 +1,222 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_VO_REGS_H__
+#define __CANAAN_VO_REGS_H__
+
+#define VO_SOFT_RST_CTL                             0x00
+#define VO_REG_LOAD_CTL                             0x04
+#define VO_DMA_SW_CTL                               0x08
+#define VO_DMA_RD_CTL_OUT                           0x0c
+#define VO_DMA_ARB_MODE                             0x10
+#define VO_DMA_WEIGHT_RD0                           0x24
+#define VO_DMA_WEIGHT_RD1                           0x28
+#define VO_DMA_WEIGHT_RD2                           0x2c
+#define VO_DMA_WEIGHT_RD3                           0x30
+#define VO_DMA_PRIORITY_RD_0                        0x3c
+#define VO_DMA_PRIORITY_RD_1                        0x40
+#define VO_DMA_ID_RD_0                              0x4c
+#define VO_DMA_ID_RD_1                              0x50
+
+#define VO_LAYER0_LINE0_BD_CTL                      0x80
+#define VO_LAYER0_LINE1_BD_CTL                      0x84
+#define VO_LAYER0_LINE2_BD_CTL                      0x88
+#define VO_LAYER0_LINE3_BD_CTL                      0x8C
+#define VO_LAYER1_BD_CTL                            0x90
+#define VO_LAYER2_BD_CTL                            0x94
+#define VO_LAYER3_BD_CTL                            0x98
+#define VO_OSD0_BD_CTL                              0x9c
+#define VO_OSD1_BD_CTL                              0xa0
+#define VO_OSD2_BD_CTL                              0xa4
+#define VO_OSD3_BD_CTL                              0x800
+#define VO_OSD4_BD_CTL                              0x804
+#define VO_OSD5_BD_CTL                              0x808
+#define VO_OSD6_BD_CTL                              0x80c
+#define VO_OSD7_BD_CTL                              0x810
+
+#define VO_DISP_IRQ0_CTL                            0x3e0
+#define VO_DISP_IRQ1_CTL                            0x3e4
+#define VO_DISP_IRQ2_CTL                            0x3e8
+#define VO_DISP_IRQ_STATUS                          0x3ec
+
+#define VO_DISP_CTL                                 0x114
+#define VO_DISP_ENABLE                              0x118
+
+#define VO_DISP_XZONE_CTL                           0x0C0
+#define VO_DISP_YZONE_CTL                           0x0C4
+#define VO_DISP_LAYER0_XCTL                         0x0C8
+#define VO_DISP_LAYER0_YCTL                         0x0CC
+#define VO_DISP_LAYER1_XCTL                         0x0D0
+#define VO_DISP_LAYER1_YCTL                         0x0D4
+#define VO_DISP_LAYER2_XCTL                         0x0D8
+#define VO_DISP_LAYER2_YCTL                         0x0DC
+#define VO_DISP_LAYER3_XCTL                         0x0E0
+#define VO_DISP_LAYER3_YCTL                         0x0E4
+#define VO_DISP_OSD0_XCTL                           0x0E8
+#define VO_DISP_OSD0_YCTL                           0x0EC
+#define VO_DISP_OSD1_XCTL                           0x0F0
+#define VO_DISP_OSD1_YCTL                           0x0F4
+#define VO_DISP_OSD2_XCTL                           0x0F8
+#define VO_DISP_OSD2_YCTL                           0x0FC
+#define VO_DISP_OSD3_XCTL                           0x820
+#define VO_DISP_OSD3_YCTL                           0x824
+#define VO_DISP_OSD4_XCTL                           0x828
+#define VO_DISP_OSD4_YCTL                           0x82C
+#define VO_DISP_OSD5_XCTL                           0x830
+#define VO_DISP_OSD5_YCTL                           0x834
+#define VO_DISP_OSD6_XCTL                           0x838
+#define VO_DISP_OSD6_YCTL                           0x83C
+#define VO_DISP_OSD7_XCTL                           0x840
+#define VO_DISP_OSD7_YCTL                           0x844
+
+#define VO_LAYER3_OFFSET                            0x240
+#define VO_LAYER3_CTL                               0x240
+#define VO_LAYER3_Y_ADDR0                           0x244
+#define VO_LAYER3_UV_ADDR0                          0x248
+#define VO_LAYER3_Y_ADDR1                           0x24C
+#define VO_LAYER3_UV_ADDR1                          0x250
+#define VO_LAYER3_IMG_IN_OFFSET                     0x254
+#define VO_LAYER3_BLENTH                            0x258
+#define VO_LAYER3_STRIDE                            0x25C
+#define VO_LAYER3_ACT_SIZE                          0x260
+#define VO_LAYER3_ADDR_SEL_MODE                     0x264
+
+#define VO_LAYER2_3_CTL_REG_OFFSET                  0x00
+#define VO_LAYER2_3_Y_ADDR0_REG_OFFSET              0x04
+#define VO_LAYER2_3_UV_ADDR0_REG_OFFSET             0x08
+#define VO_LAYER2_3_Y_ADDR1_REG_OFFSET              0x0C
+#define VO_LAYER2_3_UV_ADDR1_REG_OFFSET             0x10
+#define VO_LAYER2_3_IMG_IN_OFFSET_REG_OFFSET        0x14
+#define VO_LAYER2_3_BLENTH_REG_OFFSET               0x18
+#define VO_LAYER2_3_STRIDE_REG_OFFSET               0x1C
+#define VO_LAYER2_3_ACT_SIZE_REG_OFFSET             0x20
+#define VO_LAYER2_3_ADDR_SEL_MODE_REG_OFFSET        0x24
+
+#define VO_OSD0_OFFSET                              0x280
+#define VO_OSD0_INFO                                0x280
+#define VO_OSD0_SIZE                                0x284
+#define VO_OSD0_VLU_ADDR0                           0x288
+#define VO_OSD0_ALP_ADDR0                           0x28C
+#define VO_OSD0_VLU_ADDR1                           0x290
+#define VO_OSD0_ALP_ADDR1                           0x294
+#define VO_OSD0_DMA_CTRL                            0x298
+#define VO_OSD0_STRIDE                              0x29C
+#define VO_OSD0_ADDR_SEL_MODE                       0x2A0
+
+#define VO_OSD1_OFFSET                              0x2C0
+#define VO_OSD1_INFO                                0x2C0
+#define VO_OSD1_SIZE                                0x2C4
+#define VO_OSD1_VLU_ADDR0                           0x2C8
+#define VO_OSD1_ALP_ADDR0                           0x2CC
+#define VO_OSD1_VLU_ADDR1                           0x2D0
+#define VO_OSD1_ALP_ADDR1                           0x2D4
+#define VO_OSD1_DMA_CTRL                            0x2D8
+#define VO_OSD1_STRIDE                              0x2DC
+#define VO_OSD1_ADDR_SEL_MODE                       0x2E0
+
+#define VO_OSD2_OFFSET                              0x300
+#define VO_OSD2_INFO                                0x300
+#define VO_OSD2_SIZE                                0x304
+#define VO_OSD2_VLU_ADDR0                           0x308
+#define VO_OSD2_ALP_ADDR0                           0x30C
+#define VO_OSD2_VLU_ADDR1                           0x310
+#define VO_OSD2_ALP_ADDR1                           0x314
+#define VO_OSD2_DMA_CTRL                            0x318
+#define VO_OSD2_STRIDE                              0x31C
+#define VO_OSD2_ADDR_SEL_MODE                       0x320
+
+#define VO_OSD3_OFFSET                              0x850
+#define VO_OSD3_INFO                                0x850
+#define VO_OSD3_SIZE                                0x854
+#define VO_OSD3_VLU_ADDR0                           0x858
+#define VO_OSD3_ALP_ADDR0                           0x85c
+#define VO_OSD3_VLU_ADDR1                           0x860
+#define VO_OSD3_ALP_ADDR1                           0x864
+#define VO_OSD3_DMA_CTRL                            0x868
+#define VO_OSD3_STRIDE                              0x86c
+#define VO_OSD3_ADDR_SEL_MODE                       0x870
+
+#define VO_OSD4_OFFSET                              0x880
+#define VO_OSD4_INFO                                0x880
+#define VO_OSD4_SIZE                                0x884
+#define VO_OSD4_VLU_ADDR0                           0x888
+#define VO_OSD4_ALP_ADDR0                           0x88c
+#define VO_OSD4_VLU_ADDR1                           0x890
+#define VO_OSD4_ALP_ADDR1                           0x894
+#define VO_OSD4_DMA_CTRL                            0x898
+#define VO_OSD4_STRIDE                              0x89c
+#define VO_OSD4_ADDR_SEL_MODE                       0x8a0
+
+#define VO_OSD5_OFFSET                              0x8b0
+#define VO_OSD5_INFO                                0x8b0
+#define VO_OSD5_SIZE                                0x8b4
+#define VO_OSD5_VLU_ADDR0                           0x8b8
+#define VO_OSD5_ALP_ADDR0                           0x8bc
+#define VO_OSD5_VLU_ADDR1                           0x8c0
+#define VO_OSD5_ALP_ADDR1                           0x8c4
+#define VO_OSD5_DMA_CTRL                            0x8c8
+#define VO_OSD5_STRIDE                              0x8cc
+#define VO_OSD5_ADDR_SEL_MODE                       0x8d0
+
+#define VO_OSD6_OFFSET                              0x8e0
+#define VO_OSD6_INFO                                0x8e0
+#define VO_OSD6_SIZE                                0x8e4
+#define VO_OSD6_VLU_ADDR0                           0x8e8
+#define VO_OSD6_ALP_ADDR0                           0x8ec
+#define VO_OSD6_VLU_ADDR1                           0x8f0
+#define VO_OSD6_ALP_ADDR1                           0x8f4
+#define VO_OSD6_DMA_CTRL                            0x8f8
+#define VO_OSD6_STRIDE                              0x8fc
+#define VO_OSD6_ADDR_SEL_MODE                       0x900
+
+#define VO_OSD7_OFFSET                              0x910
+#define VO_OSD7_INFO                                0x910
+#define VO_OSD7_SIZE                                0x914
+#define VO_OSD7_VLU_ADDR0                           0x918
+#define VO_OSD7_ALP_ADDR0                           0x91c
+#define VO_OSD7_VLU_ADDR1                           0x920
+#define VO_OSD7_ALP_ADDR1                           0x924
+#define VO_OSD7_DMA_CTRL                            0x928
+#define VO_OSD7_STRIDE                              0x92c
+#define VO_OSD7_ADDR_SEL_MODE                       0x930
+
+#define VO_OSD0_7_INFO_REG_OFFSET                   0x00
+#define VO_OSD0_7_SIZE_REG_OFFSET                   0x04
+#define VO_OSD0_7_VLU_ADDR0_REG_OFFSET              0x08
+#define VO_OSD0_7_ALP_ADDR0_REG_OFFSET              0x0C
+#define VO_OSD0_7_VLU_ADDR1_REG_OFFSET              0x10
+#define VO_OSD0_7_ALP_ADDR1_REG_OFFSET              0x14
+#define VO_OSD0_7_DMA_CTRL_REG_OFFSET               0x18
+#define VO_OSD0_7_STRIDE_REG_OFFSET                 0x1C
+#define VO_OSD0_7_ADDR_SEL_MODE_REG_OFFSET          0x20
+
+#define VO_CONFIG_LINE_BASE                         0x0600
+#define VO_HSCALE_BASE                              0x8000
+#define VO_VSCALE_BASE                              0x8C00
+#define VO_GAMMA_BASE                               0xC000
+
+#define VO_DISP_BACKGROUND                          0x3D0
+#define VO_DISP_MIX_LAYER_GLB_EN                    0x3c0
+#define VO_DISP_MIX_LAYER_GLB_ALPHA0                0x3c4
+#define VO_DISP_MIX_LAYER_GLB_ALPHA1                0x3c8
+#define VO_DISP_MIX_SEL                             0x3cc
+
+#define VO_DISP_YUV2RGB_CTL                         0x380
+#define VO_DISP_CLUT_CTL                            0x3d8
+#define VO_DISP_DITH_CTL                            0x3d4
+#define VO_OSD_RGB2YUV_CTL                          0x340
+
+#define VO_DISP_HSYNC_CTL                           0x100
+#define VO_DISP_HSYNC1_CTL                          0x104
+#define VO_DISP_VSYNC1_CTL                          0x108
+#define VO_DISP_VSYNC2_CTL                          0x110
+#define VO_DISP_HSYNC2_CTL                          0x10c
+#define VO_DISP_TOTAL_SIZE                          0x11C
+#define VO_DISP_XZONE_CTL                           0x0C0
+#define VO_DISP_YZONE_CTL                           0x0C4
+
+#endif /* __CANAAN_VO_REGS_H__ */
diff --git a/drivers/gpu/drm/canaan/canaan_vo_table.h b/drivers/gpu/drm/canaan/canaan_vo_table.h
new file mode 100755
index 000000000..ef89d1734
--- /dev/null
+++ b/drivers/gpu/drm/canaan/canaan_vo_table.h
@@ -0,0 +1,615 @@
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __CANAAN_VO_TABLE_H__
+#define __CANAAN_VO_TABLE_H__
+
+
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+/*
+*v scale coeff
+*/
+int V_Coef[128] =
+{
+    0x400000,
+    0x000000,
+    0x3ffff8,
+    0xfff008,
+    0x3fdff0,
+    0xfff011,
+    0x3fafea,
+    0xffe01c,
+    0x3f6fe3,
+    0xffe027,
+    0x3f1fde,
+    0xffd033,
+    0x3eafd8,
+    0xffb040,
+    0x3e3fd3,
+    0xffa04e,
+    0x3dbfcf,
+    0xff905d,
+    0x3d1fca,
+    0xff706c,
+    0x3c7fc7,
+    0xff507c,
+    0x3bcfc3,
+    0xff308c,
+    0x3b0fc0,
+    0xff109d,
+    0x3a3fbd,
+    0xfef0af,
+    0x395fbb,
+    0xfec0c1,
+    0x387fb9,
+    0xfea0d4,
+    0x378fb8,
+    0xfe80e8,
+    0x368fb6,
+    0xfe50fb,
+    0x357fb5,
+    0xfe210f,
+    0x346fb4,
+    0xfe0124,
+    0x334fb4,
+    0xfdd139,
+    0x322fb4,
+    0xfda14e,
+    0x30ffb4,
+    0xfd8163,
+    0x2fcfb4,
+    0xfd5179,
+    0x2e9fb5,
+    0xfd318f,
+    0x2d4fb5,
+    0xfd01a4,
+    0x2c0fb6,
+    0xfcd1bb,
+    0x2abfb7,
+    0xfcb1d1,
+    0x296fb9,
+    0xfc81e7,
+    0x281fba,
+    0xfc61fd,
+    0x26bfbc,
+    0xfc4213,
+    0x255fbe,
+    0xfc2229,
+    0x240fc0,
+    0xfc0240,
+    0x229fc2,
+    0xfbe255,
+    0x213fc4,
+    0xfbc26b,
+    0x1fdfc6,
+    0xfba281,
+    0x1e7fc8,
+    0xfb9296,
+    0x1d1fcb,
+    0xfb72ab,
+    0x1bbfcd,
+    0xfb62c0,
+    0x1a4fd0,
+    0xfb52d4,
+    0x18ffd3,
+    0xfb52e9,
+    0x179fd5,
+    0xfb42fc,
+    0x163fd8,
+    0xfb430f,
+    0x14efda,
+    0xfb4322,
+    0x139fdd,
+    0xfb4334,
+    0x124fe0,
+    0xfb4346,
+    0x10ffe2,
+    0xfb5357,
+    0x0fbfe5,
+    0xfb6368,
+    0x0e8fe8,
+    0xfb8378,
+    0x0d4fea,
+    0xfb9387,
+    0x0c1fec,
+    0xfbb395,
+    0x0affef,
+    0xfbd3a3,
+    0x09dff1,
+    0xfc03b0,
+    0x08cff3,
+    0xfc33bc,
+    0x07cff5,
+    0xfc73c7,
+    0x06cff7,
+    0xfca3d1,
+    0x05dff9,
+    0xfcf3db,
+    0x04effa,
+    0xfd33e3,
+    0x040ffb,
+    0xfd83ea,
+    0x033ffd,
+    0xfde3f1,
+    0x027ffe,
+    0xfe33f6,
+    0x01cffe,
+    0xfea3fa,
+    0x011fff,
+    0xff03fd,
+    0x008fff,
+    0xff83ff
+};
+
+/*
+*h scale coeff
+*/
+int H_Coef[192] =
+{
+    0x00000000,
+    0x00004000,
+    0x00000000,
+    0xf8000000,
+    0xf0083fff,
+    0x000000ff,
+    0xf0000000,
+    0xf0113fdf,
+    0x000000ff,
+    0xea000000,
+    0xe01c3faf,
+    0x000000ff,
+    0xe3000000,
+    0xe0273f6f,
+    0x000000ff,
+    0xde000000,
+    0xd0333f1f,
+    0x000000ff,
+    0xd8000000,
+    0xb0403eaf,
+    0x000000ff,
+    0xd3000000,
+    0xa04e3e3f,
+    0x000000ff,
+    0xcf000000,
+    0x905d3dbf,
+    0x000000ff,
+    0xca000000,
+    0x706c3d1f,
+    0x000000ff,
+    0xc7000000,
+    0x507c3c7f,
+    0x000000ff,
+    0xc3000000,
+    0x308c3bcf,
+    0x000000ff,
+    0xc0000000,
+    0x109d3b0f,
+    0x000000ff,
+    0xbd000000,
+    0xf0af3a3f,
+    0x000000fe,
+    0xbb000000,
+    0xc0c1395f,
+    0x000000fe,
+    0xb9000000,
+    0xa0d4387f,
+    0x000000fe,
+    0xb8000000,
+    0x80e8378f,
+    0x000000fe,
+    0xb6000000,
+    0x50fb368f,
+    0x000000fe,
+    0xb5000000,
+    0x210f357f,
+    0x000000fe,
+    0xb4000000,
+    0x0124346f,
+    0x000000fe,
+    0xb4000000,
+    0xd139334f,
+    0x000000fd,
+    0xb4000000,
+    0xa14e322f,
+    0x000000fd,
+    0xb4000000,
+    0x816330ff,
+    0x000000fd,
+    0xb4000000,
+    0x51792fcf,
+    0x000000fd,
+    0xb5000000,
+    0x318f2e9f,
+    0x000000fd,
+    0xb5000000,
+    0x01a42d4f,
+    0x000000fd,
+    0xb6000000,
+    0xd1bb2c0f,
+    0x000000fc,
+    0xb7000000,
+    0xb1d12abf,
+    0x000000fc,
+    0xb9000000,
+    0x81e7296f,
+    0x000000fc,
+    0xba000000,
+    0x61fd281f,
+    0x000000fc,
+    0xbc000000,
+    0x421326bf,
+    0x000000fc,
+    0xbe000000,
+    0x2229255f,
+    0x000000fc,
+    0xc0000000,
+    0x0240240f,
+    0x000000fc,
+    0xc2000000,
+    0xe255229f,
+    0x000000fb,
+    0xc4000000,
+    0xc26b213f,
+    0x000000fb,
+    0xc6000000,
+    0xa2811fdf,
+    0x000000fb,
+    0xc8000000,
+    0x92961e7f,
+    0x000000fb,
+    0xcb000000,
+    0x72ab1d1f,
+    0x000000fb,
+    0xcd000000,
+    0x62c01bbf,
+    0x000000fb,
+    0xd0000000,
+    0x52d41a4f,
+    0x000000fb,
+    0xd3000000,
+    0x52e918ff,
+    0x000000fb,
+    0xd5000000,
+    0x42fc179f,
+    0x000000fb,
+    0xd8000000,
+    0x430f163f,
+    0x000000fb,
+    0xda000000,
+    0x432214ef,
+    0x000000fb,
+    0xdd000000,
+    0x4334139f,
+    0x000000fb,
+    0xe0000000,
+    0x4346124f,
+    0x000000fb,
+    0xe2000000,
+    0x535710ff,
+    0x000000fb,
+    0xe5000000,
+    0x63680fbf,
+    0x000000fb,
+    0xe8000000,
+    0x83780e8f,
+    0x000000fb,
+    0xea000000,
+    0x93870d4f,
+    0x000000fb,
+    0xec000000,
+    0xb3950c1f,
+    0x000000fb,
+    0xef000000,
+    0xd3a30aff,
+    0x000000fb,
+    0xf1000000,
+    0x03b009df,
+    0x000000fc,
+    0xf3000000,
+    0x33bc08cf,
+    0x000000fc,
+    0xf5000000,
+    0x73c707cf,
+    0x000000fc,
+    0xf7000000,
+    0xa3d106cf,
+    0x000000fc,
+    0xf9000000,
+    0xf3db05df,
+    0x000000fc,
+    0xfa000000,
+    0x33e304ef,
+    0x000000fd,
+    0xfb000000,
+    0x83ea040f,
+    0x000000fd,
+    0xfd000000,
+    0xe3f1033f,
+    0x000000fd,
+    0xfe000000,
+    0x33f6027f,
+    0x000000fe,
+    0xfe000000,
+    0xa3fa01cf,
+    0x000000fe,
+    0xff000000,
+    0x03fd011f,
+    0x000000ff,
+    0xff000000,
+    0x83ff008f,
+    0x000000ff
+};
+/*
+*gamma coeff
+*/
+int  GammaCoef[256] =
+{
+    0b00000000,
+    0b00000001,
+    0b00000010,
+    0b00000011,
+    0b00000100,
+    0b00000101,
+    0b00000110,
+    0b00000111,
+    0b00001000,
+    0b00001001,
+    0b00001010,
+    0b00001011,
+    0b00001100,
+    0b00001101,
+    0b00001110,
+    0b00001111,
+    0b00010000,
+    0b00010001,
+    0b00010010,
+    0b00010011,
+    0b00010100,
+    0b00010101,
+    0b00010110,
+    0b00010111,
+    0b00011000,
+    0b00011001,
+    0b00011010,
+    0b00011011,
+    0b00011100,
+    0b00011101,
+    0b00011110,
+    0b00011111,
+    0b00100000,
+    0b00100001,
+    0b00100010,
+    0b00100011,
+    0b00100100,
+    0b00100101,
+    0b00100110,
+    0b00100111,
+    0b00101000,
+    0b00101001,
+    0b00101010,
+    0b00101011,
+    0b00101100,
+    0b00101101,
+    0b00101110,
+    0b00101111,
+    0b00110000,
+    0b00110001,
+    0b00110010,
+    0b00110011,
+    0b00110100,
+    0b00110101,
+    0b00110110,
+    0b00110111,
+    0b00111000,
+    0b00111001,
+    0b00111010,
+    0b00111011,
+    0b00111100,
+    0b00111101,
+    0b00111110,
+    0b00111111,
+    0b01000000,
+    0b01000001,
+    0b01000010,
+    0b01000011,
+    0b01000100,
+    0b01000101,
+    0b01000110,
+    0b01000111,
+    0b01001000,
+    0b01001001,
+    0b01001010,
+    0b01001011,
+    0b01001100,
+    0b01001101,
+    0b01001110,
+    0b01001111,
+    0b01010000,
+    0b01010001,
+    0b01010010,
+    0b01010011,
+    0b01010100,
+    0b01010101,
+    0b01010110,
+    0b01010111,
+    0b01011000,
+    0b01011001,
+    0b01011010,
+    0b01011011,
+    0b01011100,
+    0b01011101,
+    0b01011110,
+    0b01011111,
+    0b01100000,
+    0b01100001,
+    0b01100010,
+    0b01100011,
+    0b01100100,
+    0b01100101,
+    0b01100110,
+    0b01100111,
+    0b01101000,
+    0b01101001,
+    0b01101010,
+    0b01101011,
+    0b01101100,
+    0b01101101,
+    0b01101110,
+    0b01101111,
+    0b01110000,
+    0b01110001,
+    0b01110010,
+    0b01110011,
+    0b01110100,
+    0b01110101,
+    0b01110110,
+    0b01110111,
+    0b01111000,
+    0b01111001,
+    0b01111010,
+    0b01111011,
+    0b01111100,
+    0b01111101,
+    0b01111110,
+    0b01111111,
+    0b10000000,
+    0b10000001,
+    0b10000010,
+    0b10000011,
+    0b10000100,
+    0b10000101,
+    0b10000110,
+    0b10000111,
+    0b10001000,
+    0b10001001,
+    0b10001010,
+    0b10001011,
+    0b10001100,
+    0b10001101,
+    0b10001110,
+    0b10001111,
+    0b10010000,
+    0b10010001,
+    0b10010010,
+    0b10010011,
+    0b10010100,
+    0b10010101,
+    0b10010110,
+    0b10010111,
+    0b10011000,
+    0b10011001,
+    0b10011010,
+    0b10011011,
+    0b10011100,
+    0b10011101,
+    0b10011110,
+    0b10011111,
+    0b10100000,
+    0b10100001,
+    0b10100010,
+    0b10100011,
+    0b10100100,
+    0b10100101,
+    0b10100110,
+    0b10100111,
+    0b10101000,
+    0b10101001,
+    0b10101010,
+    0b10101011,
+    0b10101100,
+    0b10101101,
+    0b10101110,
+    0b10101111,
+    0b10110000,
+    0b10110001,
+    0b10110010,
+    0b10110011,
+    0b10110100,
+    0b10110101,
+    0b10110110,
+    0b10110111,
+    0b10111000,
+    0b10111001,
+    0b10111010,
+    0b10111011,
+    0b10111100,
+    0b10111101,
+    0b10111110,
+    0b10111111,
+    0b11000000,
+    0b11000001,
+    0b11000010,
+    0b11000011,
+    0b11000100,
+    0b11000101,
+    0b11000110,
+    0b11000111,
+    0b11001000,
+    0b11001001,
+    0b11001010,
+    0b11001011,
+    0b11001100,
+    0b11001101,
+    0b11001110,
+    0b11001111,
+    0b11010000,
+    0b11010001,
+    0b11010010,
+    0b11010011,
+    0b11010100,
+    0b11010101,
+    0b11010110,
+    0b11010111,
+    0b11011000,
+    0b11011001,
+    0b11011010,
+    0b11011011,
+    0b11011100,
+    0b11011101,
+    0b11011110,
+    0b11011111,
+    0b11100000,
+    0b11100001,
+    0b11100010,
+    0b11100011,
+    0b11100100,
+    0b11100101,
+    0b11100110,
+    0b11100111,
+    0b11101000,
+    0b11101001,
+    0b11101010,
+    0b11101011,
+    0b11101100,
+    0b11101101,
+    0b11101110,
+    0b11101111,
+    0b11110000,
+    0b11110001,
+    0b11110010,
+    0b11110011,
+    0b11110100,
+    0b11110101,
+    0b11110110,
+    0b11110111,
+    0b11111000,
+    0b11111001,
+    0b11111010,
+    0b11111011,
+    0b11111100,
+    0b11111101,
+    0b11111110,
+    0b11111111
+};
+
+
+#endif /* __CANAAN_TABLE_H__ */
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 869e535fa..d09ab1647 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -835,4 +835,13 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
+config DRM_PANEL_CANAAN_UNIVERSAL
+	tristate "Canaan universal panel driver"
+	default ARCH_CANAAN
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for canaan universal panels
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 433e93d57..4dd8d8389 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -85,3 +85,4 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_CANAAN_UNIVERSAL) += panel-canaan-universal.o
diff --git a/drivers/gpu/drm/panel/panel-canaan-universal.c b/drivers/gpu/drm/panel/panel-canaan-universal.c
new file mode 100644
index 000000000..ff6cb89bf
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-canaan-universal.c
@@ -0,0 +1,419 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2022, Canaan Bright Sight Co., Ltd
+ *
+ * All enquiries to https://www.canaan-creative.com/
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+
+struct canaan_panel_instr {
+	char cmd;
+	char data;
+};
+
+struct canaan_panel_desc {
+	const struct canaan_panel_instr *init;
+	const size_t init_length;
+	//const struct drm_display_mode *mode;
+};
+
+struct panel_cmd_header {
+	u8 data_type;
+	u8 delay;
+	u8 payload_length;
+} __packed;
+
+struct panel_cmd_desc {
+	struct panel_cmd_header header;
+	u8 *payload;
+};
+
+struct panel_cmd_seq {
+	struct panel_cmd_desc *cmds;
+	unsigned int cmd_cnt;
+};
+
+
+struct canaan_panel {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	const struct canaan_panel_desc	*desc;
+
+	struct regulator *power;
+	struct gpio_desc *reset;
+	struct gpio_desc *power_on;
+	struct videomode vm;
+	u32 width_mm;
+	u32 height_mm;
+	u32 lan_num;
+	u32 init_set_v1_flag;
+
+	struct panel_cmd_seq *init_seq_v1;
+};
+
+
+// static const struct canaan_panel_instr hx8399_init[] = {
+	
+// };
+
+
+static inline struct canaan_panel *panel_to_canaan_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct canaan_panel, panel);
+}
+
+static void panel_simple_sleep(unsigned int msec)
+{
+	if (msec > 20)
+		msleep(msec);
+	else
+		usleep_range(msec * 1000, (msec + 1) * 1000);
+
+}
+
+static int panel_simple_xfer_dsi_cmd_seq(struct canaan_panel *panel,
+				     struct panel_cmd_seq *seq)
+{
+	
+	struct device *dev = panel->panel.dev;
+	struct mipi_dsi_device *dsi = panel->dsi;
+	unsigned int i;
+	int err;
+
+	if (!seq)
+		return -EINVAL;
+
+	for (i = 0; i < seq->cmd_cnt; i++) {
+		struct panel_cmd_desc *cmd = &seq->cmds[i];
+
+		switch (cmd->header.data_type) {
+			case MIPI_DSI_DCS_SHORT_WRITE:
+			case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+				// printk("panel_simple_xfer_dsi_cmd_seq short package \n");
+				err = mipi_dsi_dcs_write_buffer(dsi, cmd->payload,
+								cmd->header.payload_length);
+				break;
+			case MIPI_DSI_DCS_LONG_WRITE:
+				// printk("panel_simple_xfer_dsi_cmd_seq  long package \n");
+				err = mipi_dsi_dcs_write_buffer(dsi, cmd->payload,
+								cmd->header.payload_length);
+				break;
+			default:
+				return -EINVAL;
+		}
+
+		if (err < 0)
+			dev_err(dev, "failed to write dcs cmd: %d\n", err);
+
+		if (cmd->header.delay)
+			panel_simple_sleep(cmd->header.delay);
+	}
+//	//printk("panel_simple_xfer_dsi_cmd_seq  end \n");
+	return 0;
+}
+
+static int canaan_panel_prepare(struct drm_panel *panel)
+{
+	struct canaan_panel *p = panel_to_canaan_panel(panel);
+	// int err;
+
+	// set power on 
+	if(!IS_ERR(p->power_on))
+	{
+		gpiod_direction_output(p->power_on, 1);
+		gpiod_set_value_cansleep(p->power_on, 1);
+	}
+	// set rst
+	if(!IS_ERR(p->reset))
+	{
+		gpiod_direction_output(p->reset, 1);
+		
+		gpiod_set_value_cansleep(p->reset, 1);
+		panel_simple_sleep(200);
+		gpiod_set_value_cansleep(p->reset, 0);
+		panel_simple_sleep(200);
+		gpiod_set_value_cansleep(p->reset, 1);
+		panel_simple_sleep(200);
+	}
+
+	if(p->init_set_v1_flag)
+	{
+		// config screen
+		panel_simple_xfer_dsi_cmd_seq(p, p->init_seq_v1);
+	}
+	printk("%s done\n", __func__);
+	return 0;
+}
+
+static int canaan_panel_enable(struct drm_panel *panel)
+{
+	
+	return 0;
+}
+
+static int canaan_panel_disable(struct drm_panel *panel)
+{
+	return 0;
+}
+
+static int canaan_panel_unprepare(struct drm_panel *panel)
+{
+	struct canaan_panel *p = panel_to_canaan_panel(panel);
+	// int err = 0;
+
+	if(p->power_on)
+	{
+		printk("power off is ok \n");
+		gpiod_set_value_cansleep(p->power_on, 0);
+	}
+	if(p->reset)
+	{
+		printk("power off reset is ok \n");
+		gpiod_set_value_cansleep(p->reset, 0);
+	}
+
+	panel_simple_sleep(500);
+
+	return 0;
+}
+
+static int canaan_panel_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	struct canaan_panel *ctx = panel_to_canaan_panel(panel);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_create(connector->dev);
+	if (!mode) {
+		dev_err(panel->dev, "failed to create a new display mode\n");
+		return 0;
+	}
+
+	drm_display_mode_from_videomode(&ctx->vm, mode);
+	mode->width_mm = ctx->width_mm;
+	mode->height_mm = ctx->height_mm;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs canaan_panel_funcs = {
+	.prepare	= canaan_panel_prepare,
+	.unprepare	= canaan_panel_unprepare,
+	.enable		= canaan_panel_enable,
+	.disable	= canaan_panel_disable,
+	.get_modes	= canaan_panel_get_modes,
+};
+
+
+static int panel_simple_parse_cmd_seq(struct device *dev,
+				      const u8 *data, int length,
+				      struct panel_cmd_seq *seq)
+{
+	struct panel_cmd_header *header;
+	struct panel_cmd_desc *desc;
+	char *buf, *d;
+	unsigned int i, cnt, len;
+
+	if (!seq)
+		return -EINVAL;
+
+	buf = devm_kmemdup(dev, data, length, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	d = buf;
+	len = length;
+	cnt = 0;
+	while (len > sizeof(*header)) {
+		header = (struct panel_cmd_header *)d;
+
+		d += sizeof(*header);
+		len -= sizeof(*header);
+
+		if (header->payload_length > len)
+			return -EINVAL;
+
+		d += header->payload_length;
+		len -= header->payload_length;
+		cnt++;
+	}
+
+	if (len)
+		return -EINVAL;
+
+	seq->cmd_cnt = cnt;
+	seq->cmds = devm_kcalloc(dev, cnt, sizeof(*desc), GFP_KERNEL);
+	if (!seq->cmds)
+		return -ENOMEM;
+
+	d = buf;
+	len = length;
+	for (i = 0; i < cnt; i++) {
+		header = (struct panel_cmd_header *)d;
+		len -= sizeof(*header);
+		d += sizeof(*header);
+
+		desc = &seq->cmds[i];
+		desc->header = *header;
+		desc->payload = d;
+
+		d += header->payload_length;
+		len -= header->payload_length;
+	}
+
+	return 0;
+}
+
+static int canaan_panel_parse_dt(struct canaan_panel *ctx)
+{
+	struct device *dev = &ctx->dsi->dev;
+	struct device_node *np = dev->of_node;
+	const void *data;
+	int ret, err;
+	int len;
+
+	// get diplay timing
+	ret = of_get_videomode(np, &ctx->vm, 0);
+	if (ret < 0)
+		return ret;
+
+	// get width && heidth
+	of_property_read_u32(np, "panel-width-mm", &ctx->width_mm);
+	of_property_read_u32(np, "panel-height-mm", &ctx->height_mm);
+	of_property_read_u32(np, "panel-dsi-lane", &ctx->lan_num);
+	
+	// get screen data
+	data = of_get_property(np, "panel-init-sequence", &len);
+	if (data) {
+		ctx->init_seq_v1 = devm_kzalloc(dev, sizeof(*ctx->init_seq_v1), GFP_KERNEL);
+		if (!ctx->init_seq_v1)
+			return -ENOMEM;
+
+		err = panel_simple_parse_cmd_seq(dev, data, len, ctx->init_seq_v1);
+		if (err) {
+			dev_err(dev, "failed to parse init sequence v1\n");
+			return err;
+		}
+		ctx->init_set_v1_flag = 1;
+	}
+
+	printk("panel-dsi-lane is %d \n", ctx->lan_num);
+	printk("panel-height-mm is %d \n", ctx->height_mm);
+	printk("ctx->init_seq_v1 cmd_cnt is %d  cmd is %d \n", ctx->init_seq_v1->cmd_cnt, ctx->init_seq_v1->cmds->header.data_type);
+
+	return 0;
+}
+
+static int canaan_panel_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct canaan_panel *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->init_set_v1_flag = 0;
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+	
+	ctx->reset = devm_gpiod_get(&dsi->dev, "dsi_reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset)) {
+		dev_err(&dsi->dev, "Couldn't get our reset GPIO, error: %ld\n", PTR_ERR(ctx->reset));
+		// return PTR_ERR(ctx->reset);
+	}
+
+	ctx->power_on = devm_gpiod_get(&dsi->dev, "backlight_gpio", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->power_on)) {
+		dev_err(&dsi->dev, "Couldn't get our backlight_gpio GPIO, error: %ld\n", PTR_ERR(ctx->power_on));
+		// return PTR_ERR(ctx->power_on);
+	}
+
+	ctx->dsi = dsi;
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	ret = canaan_panel_parse_dt(ctx);
+	if (ret < 0)
+		return ret;
+
+	// Panel Device Tree Read..
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->lanes = ctx->lan_num;
+
+	drm_panel_init(&ctx->panel, &dsi->dev, &canaan_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret) {
+		drm_panel_remove(&ctx->panel);
+	}
+
+	return ret;
+}
+
+static void canaan_panel_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	struct canaan_panel *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return;
+}
+
+// static const struct canaan_panel_desc hx8399_desc = {
+// 	// .init = hx8399_init,
+// 	// .init_length = ARRAY_SIZE(hx8399_init),
+// 	// .mode = &hx8399_default_mode,
+// };
+
+
+static const struct of_device_id canaan_panel_of_match[] = {
+	{ .compatible = "canaan,hx8399",},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, canaan_panel_of_match);
+
+static struct mipi_dsi_driver canaan_panel_driver = {
+	.probe		= canaan_panel_dsi_probe,
+	.remove		= canaan_panel_dsi_remove,
+	.driver = {
+		.name		= "canaan-panel-dsi",
+		.of_match_table	= canaan_panel_of_match,
+	},
+};
+module_mipi_dsi_driver(canaan_panel_driver);
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("Canaan K230 Panel Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/vglite/Kconfig b/drivers/gpu/vglite/Kconfig
new file mode 100644
index 000000000..99404e0ad
--- /dev/null
+++ b/drivers/gpu/vglite/Kconfig
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config VG_LITE
+	tristate "VGLite device driver"
+	default n
+	help
+	  VGLite GPU
diff --git a/drivers/gpu/vglite/Makefile b/drivers/gpu/vglite/Makefile
new file mode 100644
index 000000000..fe65d8f75
--- /dev/null
+++ b/drivers/gpu/vglite/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+vg_lite-objs := vg_lite_hal.o vg_lite_kernel.o
+obj-$(CONFIG_VG_LITE)  += vg_lite.o
diff --git a/drivers/gpu/vglite/vg_lite_debug.h b/drivers/gpu/vglite/vg_lite_debug.h
new file mode 100644
index 000000000..a3b4ac608
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_debug.h
@@ -0,0 +1,85 @@
+/****************************************************************************
+*
+*    Copyright 2012 - 2023 Vivante Corporation, Santa Clara, California.
+*    All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_debug_h_
+#define _vg_lite_debug_h_
+
+#include "vg_lite_kernel.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VGL_DEBUG
+#define VGL_TRACE
+
+#ifdef VGL_DEBUG
+# define vg_lite_kernel_print(fmt, arg...) printk(KERN_DEBUG "[VGL DEBUG] "fmt,##arg)
+#else
+# define vg_lite_kernel_print(fmt, arg...) do{}while(VG_FALSE)
+#endif
+
+#ifdef VGL_TRACE
+# define vg_lite_kernel_trace() printk(KERN_DEBUG "[VGL TRACE] [%s, %d, %s]", __FUNCTION__, __LINE__, __FILE__)
+#else
+# define vg_lite_kernel_trace() do{}while(VG_FALSE)
+#endif
+
+#define vg_lite_kernel_error(fmt, arg...) printk(KERN_ERR "[VGL ERROR] "fmt,##arg)
+#define vg_lite_kernel_hintmsg(fmt, arg...) printk(KERN_INFO "[VGL HINTMSG] "fmt,##arg)
+
+#define VG_IS_SUCCESS(error) (error == VG_LITE_SUCCESS)
+#define VG_IS_ERROR(error)   (error != VG_LITE_SUCCESS)
+
+#define ONERROR(func) \
+        do \
+        { \
+            error = func; \
+            if (VG_IS_ERROR(error)) \
+            { \
+                vg_lite_kernel_error("%d %s(%d)\n", error, __FUNCTION__, __LINE__); \
+                goto on_error; \
+            } \
+        } \
+        while (VG_FALSE)
+
+#define ASSERT(arg) \
+           do \
+           { \
+               if (!(arg)) \
+               { \
+                   error = VG_LITE_INVALID_ARGUMENT;\
+                   goto on_error; \
+               } \
+           } \
+           while (VG_FALSE)
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/gpu/vglite/vg_lite_hal.c b/drivers/gpu/vglite/vg_lite_hal.c
new file mode 100644
index 000000000..07fd3c4a8
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_hal.c
@@ -0,0 +1,908 @@
+/****************************************************************************
+ *
+ *   The MIT License (MIT)
+ *
+ *   Copyright (c) 2014 - 2020 Vivante Corporation
+ *
+ *   Permission is hereby granted, free of charge, to any person obtaining a
+ *   copy of this software and associated documentation files (the "Software"),
+ *   to deal in the Software without restriction, including without limitation
+ *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *   and/or sell copies of the Software, and to permit persons to whom the
+ *   Software is furnished to do so, subject to the following conditions:
+ *
+ *   The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ *
+ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ *   DEALINGS IN THE SOFTWARE.
+ *
+ *****************************************************************************
+ *
+ *   The GPL License (GPL)
+ *
+ *   Copyright (C) 2014 - 2020 Vivante Corporation
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version 2
+ *   of the License, or (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software Foundation,
+ *   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ *****************************************************************************
+ *
+ *   Note: This software is released under dual MIT and GPL licenses. A
+ *   recipient may use this file under the terms of either the MIT license or
+ *   GPL License. If you wish to use only one license not the other, you can
+ *   indicate your decision by deleting one of the above license notices in your
+ *   version of this file.
+ *
+ *****************************************************************************/
+
+#include "linux/device/bus.h"
+#include "linux/dma-direction.h"
+#include "linux/err.h"
+#include "linux/kern_levels.h"
+#include "linux/module.h"
+#include "linux/power_supply.h"
+#include "linux/printk.h"
+#include "linux/scatterlist.h"
+#include "linux/slab.h"
+#include "linux/types.h"
+#include "vg_lite_platform.h"
+#include "vg_lite_kernel.h"
+#include "vg_lite_hal.h"
+#include "vg_lite_ioctl.h"
+#include "vg_lite_hw.h"
+#include "vg_lite_type.h"
+#include "vg_lite_debug.h"
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/pagemap.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/mm_types.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-buf.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+
+MODULE_LICENSE("Dual MIT/GPL");
+#ifdef MODULE_IMPORT_NS
+MODULE_IMPORT_NS(DMA_BUF);
+#endif
+
+static int vg_lite_init(struct platform_device *pdev);
+static int vg_lite_exit(struct platform_device *pdev);
+
+#if KERNEL_VERSION(3, 7, 0) <= LINUX_VERSION_CODE
+#define VM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP)
+#else
+#define VM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
+#endif
+
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
+#define current_mm_mmap_sem current->mm->mmap_lock
+#else
+#define current_mm_mmap_sem current->mm->mmap_sem
+#endif
+
+#define GET_PAGE_COUNT(size, p_size) \
+( \
+((size) + (p_size) - 1) / p_size \
+)
+
+/* Struct definitions. */
+struct dma_node {
+    struct list_head list;
+    dma_addr_t dma_addr;
+    void* virt_addr;
+    unsigned long size;
+    vg_lite_kernel_map_memory_t map;
+};
+
+enum um_desc_type {
+    UM_PAGE_MAP,
+    UM_PFN_MAP,
+};
+
+struct mapped_memory {
+    struct list_head list;
+    vg_lite_uint32_t  flags; 
+    
+    union {
+        struct {
+            /* parse user dma_buf fd */
+            vg_lite_pointer usr_dmabuf;
+    
+            /* Descriptor of a dma_buf imported. */
+            struct dma_buf *dmabuf;
+            struct sg_table *sgt;
+            struct dma_buf_attachment *attachment;
+            vg_lite_uintptr_t *dma_address_array;
+    
+            vg_lite_int32_t npages;
+            vg_lite_int32_t pid;
+            struct list_head list;
+        } dmabuf_desc;
+    
+        struct {
+            enum um_desc_type type;
+
+            vg_lite_pointer   logical;
+            vg_lite_uintptr_t physical;
+            vg_lite_int32_t   page_count;
+
+            union {
+                /* UM_PAGE_MAP. */
+                struct {
+                    struct page  **pages;
+                };
+    
+                /* UM_PFN_MAP. */
+                struct {
+                    vg_lite_long_t  *pfns;
+                    vg_lite_int32_t *refs;
+                    vg_lite_int32_t  pfns_valid;
+               };
+            };
+    
+            /* TODO: Map pages to sg table. */
+            struct sg_table   sgt;
+            vg_lite_uint32_t  alloc_from_res;
+    
+            /* record user data */
+            vg_lite_uintptr_t user_vaddr;
+            vg_lite_uint32_t  size;
+            vg_lite_flag_t    vm_flags;
+        } um_desc;
+    };
+};
+
+struct vg_lite_device {
+    void *gpu;             /* Register memory base */
+    struct page *pages;
+    unsigned int order;
+    void *virtual;
+    u32 physical;
+    u32 size;
+    int irq_enabled;
+
+    volatile u32 int_flags;
+
+    wait_queue_head_t int_queue;
+    void *device;
+    int registered;
+    int major;
+    struct class *class;
+    struct device *dev;
+    struct clk* clk;
+    struct reset_control *reset;
+    struct list_head dma_list_head;
+    struct list_head mapped_list_head;
+    int created;
+};
+
+struct client_data {
+    struct vg_lite_device *device;
+    struct vm_area_struct *vm;
+    void *contiguous_mapped;
+};
+
+/* Data and objects declarations. */
+static int verbose = 1;
+static int cached = 1;
+
+static struct vg_lite_device *device;
+static struct client_data *private_data;
+
+void vg_lite_hal_delay(u32 milliseconds) {
+    /* Delay the requested amount. */
+    msleep(milliseconds);
+}
+
+void vg_lite_hal_barrier(void) {
+    smp_mb();
+    if (cached) {
+        flush_cache_all();
+    }
+}
+
+void vg_lite_hal_initialize(void) {};
+void vg_lite_hal_deinitialize(void) {};
+
+void vg_lite_hal_open(void) {
+    // Power-on
+    pm_runtime_get_sync(device->dev);
+    // Reset
+    if (!IS_ERR(device->reset))
+        reset_control_reset(device->reset);
+}
+
+void vg_lite_hal_close(void) {
+    // Power-off
+    pm_runtime_put_sync(device->dev);
+}
+
+#define VG_LITE_PAD(number, align_bytes) \
+        ((number) + (((align_bytes) - (number) % (align_bytes)) % (align_bytes)))
+
+vg_lite_error_t vg_lite_hal_allocate_contiguous(unsigned long size, void **logical, void ** klogical, u32 *physical, void **node) {
+    struct dma_node* n = kmalloc(sizeof(struct dma_node), GFP_KERNEL);
+    if (!n) {
+        return VG_LITE_OUT_OF_MEMORY;
+    }
+#define MANUAL_ALIGN 1
+    /* FIXME: Align phy address to 64 bytes, manualy align trig tainted. */
+#if MANUAL_ALIGN
+    size = VG_LITE_ALIGN(size, 64);
+#endif
+    n->size = size;
+    n->virt_addr = dma_alloc_coherent(device->dev, size, &n->dma_addr, GFP_KERNEL | GFP_DMA);
+    if (!n->virt_addr) {
+        kfree(n);
+        return VG_LITE_OUT_OF_MEMORY;
+    }
+    // map
+    n->map.bytes = n->size;
+    n->map.physical = n->dma_addr;
+    if (vg_lite_hal_map_memory(&n->map) != VG_LITE_SUCCESS) {
+        dma_free_coherent(device->dev, n->size, n->virt_addr, n->dma_addr);
+        kfree(n);
+        return VG_LITE_OUT_OF_RESOURCES;
+    }
+    list_add(&n->list, &device->dma_list_head);
+#if MANUAL_ALIGN
+    *klogical = (u8*)VG_LITE_PAD((size_t)n->virt_addr, 64);
+    *logical = (u8*)VG_LITE_PAD((size_t)n->map.logical, 64);
+    *physical = VG_LITE_PAD(n->map.physical, 64);
+#else
+    *logical = n->map.logical;
+    *physical = n->map.physical;
+#endif
+    *node = n;
+    printk(KERN_INFO "vg_lite: alloc %lu bytes, v: %016lX, p: %08X\n", size, (size_t)n->map.logical, (u32)n->map.physical);
+    return VG_LITE_SUCCESS;
+}
+
+void vg_lite_hal_free_contiguous(void *memory_handle)
+{
+    struct dma_node* n = memory_handle;
+    vg_lite_kernel_unmap_memory_t unmap = {.bytes = n->map.bytes, .logical = n->map.logical};
+    vg_lite_hal_unmap_memory(&unmap);
+    dma_free_coherent(device->dev, n->size, n->virt_addr, n->dma_addr);
+    list_del(&n->list);
+    kfree(n);
+    return;
+}
+
+void vg_lite_hal_free_os_heap(void)
+{
+    struct dma_node* dn;
+    struct dma_node* dn2;
+    struct mapped_memory* mapped, *_mapped;
+    list_for_each_entry_safe(dn, dn2, &device->dma_list_head, list) {
+        vg_lite_hal_free_contiguous(dn);
+    }
+    list_for_each_entry_safe(mapped, _mapped, &device->mapped_list_head, list) {
+        vg_lite_hal_unmap(mapped);
+    }
+}
+
+u32 vg_lite_hal_peek(u32 address)
+{
+    /* Read data from the GPU register. */
+    return *(volatile u32 *)((uint8_t *)device->gpu + address);
+    //return readl(device->gpu + address);
+}
+
+void vg_lite_hal_poke(u32 address, u32 data)
+{
+    /* Write data to the GPU register. */
+    *(volatile u32 *)((uint8_t *)device->gpu + address) = data;
+    //writel(device->gpu + address, data);
+}
+
+vg_lite_error_t vg_lite_hal_query_mem(vg_lite_kernel_mem_t *mem)
+{
+    // FIXME: not impliment
+    if (device) {
+        mem->bytes = 0;
+        return VG_LITE_SUCCESS;
+    }
+    mem->bytes = 0;
+    return VG_LITE_NO_CONTEXT;
+}
+
+vg_lite_error_t vg_lite_hal_map_memory(vg_lite_kernel_map_memory_t *node)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    void *_logical = NULL;
+    u64 physical = node->physical;
+    u32 offset = physical & (PAGE_SIZE - 1);
+    u64 bytes = node->bytes + offset;
+    u32 num_pages, pfn = 0;
+    vg_lite_kernel_unmap_memory_t unmap_node;
+    struct vm_area_struct *vma;
+
+#if KERNEL_VERSION(3, 4, 0) <= LINUX_VERSION_CODE
+    _logical = (void *)vm_mmap(NULL, 0L, bytes, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_NORESERVE, 0);
+#else
+    down_write(&current_mm_mmap_sem);
+    _logical = (void *)do_mmap_pgoff(NULL, 0L, bytes,
+                PROT_READ | PROT_WRITE, MAP_SHARED, 0);
+    up_write(&current_mm_mmap_sem);
+#endif
+
+    if (!_logical) {
+        node->logical = NULL;
+        return VG_LITE_OUT_OF_MEMORY;
+    }
+
+    down_write(&current_mm_mmap_sem);
+
+    vma = find_vma(current->mm, (unsigned long)_logical);
+
+    if (!vma)
+        return VG_LITE_OUT_OF_RESOURCES;
+
+    pfn = (physical >> PAGE_SHIFT);
+    num_pages = GET_PAGE_COUNT(bytes, PAGE_SIZE);
+
+    /* Make this mapping cached / non-cached. */
+    if (!cached) {
+#if defined(__arm64__) || defined(__aarch64__)
+        vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+#else
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
+    }
+
+#if KERNEL_VERSION(3, 7, 0) > LINUX_VERSION_CODE
+    vm->vm_flags |= (VM_DONTCOPY | VM_RESERVED);
+#else
+    // FIXME
+    // vma->vm_flags |= (VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP);
+#endif
+
+    if (remap_pfn_range(vma, vma->vm_start, pfn, num_pages << PAGE_SHIFT, vma->vm_page_prot) < 0)
+        error = VG_LITE_OUT_OF_MEMORY;
+
+    node->logical = (void *)((uint8_t *)_logical + offset);
+
+    up_write(&current_mm_mmap_sem);
+
+    if (error) {
+        unmap_node.bytes = node->bytes;
+        unmap_node.logical = node->logical;
+        vg_lite_hal_unmap_memory(&unmap_node);
+    }
+
+    return error;
+}
+
+vg_lite_error_t vg_lite_hal_unmap_memory(vg_lite_kernel_unmap_memory_t *node)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    void *_logical;
+    u32 bytes;
+    u32 offset = (u64)node->logical & (PAGE_SIZE - 1);
+
+    if (unlikely(!current->mm))
+        return error;
+
+    _logical = (void *)((uint8_t *)node->logical - offset);
+    bytes = GET_PAGE_COUNT(node->bytes + offset, PAGE_SIZE) * PAGE_SIZE;
+
+#if KERNEL_VERSION(3, 4, 0) <= LINUX_VERSION_CODE
+    if (vm_munmap((unsigned long)_logical, bytes) < 0) {
+        error = VG_LITE_INVALID_ARGUMENT;
+        printk(KERN_WARNING "%s: vm_munmap failed\n", __func__);
+    }
+#else
+    down_write(&current_mm_mmap_sem);
+    if (do_munmap(current->mm, (unsigned long)_logical, bytes) < 0) {
+       error = VG_LITE_INVALID_ARGUMENT;
+       printk(KERN_WARNING "%s: do_munmap failed\n", __func__);
+    }
+    up_write(&current_mm_mmap_sem);
+#endif
+
+    return error;
+}
+
+int vg_lite_hal_wait_interrupt(u32 timeout, u32 mask, u32 *value)
+{
+    // FIXME: struct timeval tv;
+    unsigned long jiffies;
+    unsigned long result;
+    #define IGNORE_INTERRUPT 0
+    #if IGNORE_INTERRUPT
+    unsigned int_flag;
+    #endif
+
+    if (timeout == VG_LITE_INFINITE) {
+        /* Set 1 second timeout. */
+        // FIXME: tv.tv_sec = 1;
+        // tv.tv_usec = 0;
+        jiffies = msecs_to_jiffies(1000);
+    } else {
+        /* Convert timeout in ms to timeval. */
+        // tv.tv_sec = timeout / 1000;
+        // tv.tv_usec = (timeout % 1000) * 1000;
+        jiffies = msecs_to_jiffies(timeout);
+    }
+
+    /* Convert timeval to jiffies. */
+    // jiffies = timeval_to_jiffies(&tv);
+
+    /* Wait for interrupt, ignoring timeout. */
+    do {
+        result = wait_event_interruptible_timeout(device->int_queue, device->int_flags & mask, jiffies);
+        #if IGNORE_INTERRUPT
+        int_flag = vg_lite_hal_peek(0x10);
+        if (int_flag) {
+            result = int_flag;
+        }
+        printk(
+            "vg_lite: waiting... idle: 0x%08X, int: 0x%08X, FE: 0x%08X 0x%08X 0x%08X\n",
+            vg_lite_hal_peek(0x4), int_flag,
+            vg_lite_hal_peek(0x500), vg_lite_hal_peek(0x504), vg_lite_hal_peek(0x508)
+        );
+        #endif
+    } while (timeout == VG_LITE_INFINITE && result == 0);
+
+    /* Report the event(s) got. */
+    if (value)
+        *value = device->int_flags & mask;
+
+    device->int_flags = 0;
+    return (result != 0);
+}
+
+vg_lite_error_t vg_lite_hal_operation_cache(void *handle, vg_lite_cache_op_t cache_op) {
+    return VG_LITE_SUCCESS;
+}
+
+vg_lite_error_t vg_lite_hal_memory_export(int32_t *fd)
+{
+    // TODO
+    return VG_LITE_NOT_SUPPORT;
+}
+
+void * vg_lite_hal_map(uint32_t flags, uint32_t bytes, void *logical, uint32_t physical, int32_t dma_buf_fd, uint32_t *gpu)
+{
+    struct mapped_memory * mapped;
+   
+    mapped = kmalloc(sizeof(struct mapped_memory), GFP_KERNEL);
+    if (mapped == NULL) {
+        return NULL;
+    }
+    memset(mapped, 0, sizeof(struct mapped_memory));
+    mapped->flags = flags;
+
+    if (flags == VG_LITE_HAL_MAP_DMABUF) {
+        struct scatterlist *sg;
+        unsigned i;
+
+        mapped->dmabuf_desc.dmabuf = dma_buf_get(dma_buf_fd);
+        if (IS_ERR(mapped->dmabuf_desc.dmabuf)) {
+            goto error;
+        }
+        mapped->dmabuf_desc.attachment = dma_buf_attach(mapped->dmabuf_desc.dmabuf, device->dev);
+        if (IS_ERR(mapped->dmabuf_desc.attachment)) {
+            dma_buf_put(mapped->dmabuf_desc.dmabuf);
+            goto error;
+        }
+        mapped->dmabuf_desc.sgt = dma_buf_map_attachment(mapped->dmabuf_desc.attachment, DMA_BIDIRECTIONAL);
+        if (IS_ERR(mapped->dmabuf_desc.sgt)) {
+            dma_buf_detach(mapped->dmabuf_desc.dmabuf, mapped->dmabuf_desc.attachment);
+            dma_buf_put(mapped->dmabuf_desc.dmabuf);
+            goto error;
+        }
+        for_each_sg(mapped->dmabuf_desc.sgt->sgl, sg, mapped->dmabuf_desc.sgt->orig_nents, i) {
+            *gpu = sg_dma_address(sg);
+        }
+    } else {
+        vg_lite_kernel_hintmsg("vg_lite_hal_map: this map type not support!\n");
+        return NULL;
+    }
+
+    list_add(&mapped->list, &device->mapped_list_head);
+    return mapped;
+
+error:
+    kfree(mapped);
+    return NULL;
+}
+
+void vg_lite_hal_unmap(void * handle)
+{
+    struct mapped_memory * mapped = handle;
+
+    if (mapped->flags == VG_LITE_HAL_MAP_DMABUF) {
+        dma_buf_unmap_attachment(mapped->dmabuf_desc.attachment, mapped->dmabuf_desc.sgt, DMA_BIDIRECTIONAL);
+
+        dma_buf_detach(mapped->dmabuf_desc.dmabuf, mapped->dmabuf_desc.attachment);
+
+        dma_buf_put(mapped->dmabuf_desc.dmabuf);
+    } else {
+        vg_lite_kernel_hintmsg("vg_lite_hal_map: this map type not support!\n");
+    }
+
+    list_del(&mapped->list);
+    kfree(mapped);
+}
+
+int drv_open(struct inode *inode, struct file *file)
+{
+    struct client_data *data;
+    printk(KERN_INFO "vg_lite: open device\n");
+    vg_lite_hal_open();
+    data = kmalloc(sizeof(*data), GFP_KERNEL);
+    if (!data) {
+        printk(KERN_ERR "vg_lite: kmalloc() return -1\n");
+        return -1;
+    }
+    data->device = device;
+    data->contiguous_mapped = NULL;
+    file->private_data = data;
+    return 0;
+}
+
+// FIXME
+int drv_release(struct inode *inode, struct file *file)
+{
+    struct client_data *data = (struct client_data *)file->private_data;
+    printk(KERN_INFO "vg_lite: close device\n");
+    vg_lite_hal_free_os_heap();
+
+    kfree(data);
+    file->private_data = NULL;
+    vg_lite_hal_close();
+
+    return 0;
+}
+
+#ifdef HAVE_UNLOCKED_IOCTL
+long drv_ioctl(struct file *file, unsigned int ioctl_code, unsigned long arg)
+#else
+static const char *vg_lite_command_string[] = {
+    "VG_LITE_INITIALIZE",
+    "VG_LITE_TERMINATE",
+    "VG_LITE_ALLOCATE",
+    "VG_LITE_FREE",
+    "VG_LITE_SUBMIT",
+    "VG_LITE_WAIT",
+    "VG_LITE_RESET",
+    "VG_LITE_DEBUG",
+    "VG_LITE_MAP",
+    "VG_LITE_UNMAP",
+    "VG_LITE_CHECK",
+    "VG_LITE_QUERY_MEM",
+    "VG_LITE_FLEXA_DISABLE",
+    "VG_LITE_FLEXA_ENABLE",
+    "VG_LITE_FLEXA_STOP_FRAME",
+    "VG_LITE_FLEXA_SET_BACKGROUND_ADDRESS",
+    "VG_LITE_MAP_MEMORY",
+    "VG_LITE_UNMAP_MEMORY",
+    "VG_LITE_BUFFER_FROM_DMA_BUF"
+
+};
+
+long drv_ioctl(/*struct inode *inode, */struct file *file, unsigned int ioctl_code, unsigned long arg)
+#endif
+{
+    struct ioctl_data arguments;
+    void *data;
+
+#ifndef HAVE_UNLOCKED_IOCTL
+    /* inode will be not used */
+    //(void)inode;
+#endif
+    private_data = (struct client_data *)file->private_data;
+    if (!private_data)
+        return -1;
+
+    if (ioctl_code != VG_LITE_IOCTL)
+        return -1;
+
+    // FIXME: if ((void *)!arg)
+    if (!arg)
+        return -1;
+
+    if (copy_from_user(&arguments, (void *)arg, sizeof(arguments)) != 0)
+        return -1;
+
+    data = kmalloc(arguments.bytes, GFP_KERNEL);
+    if (!data)
+        return -1;
+
+    if (copy_from_user(data, arguments.buffer, arguments.bytes) != 0)
+        goto error;
+
+    if (arguments.command < sizeof(vg_lite_command_string) / 8) {
+        if (verbose)
+            printk(KERN_INFO "vg_lite: ioctl %s\n", vg_lite_command_string[arguments.command]);
+    } else {
+        printk(KERN_ERR "vg_lite: ioctl unknown command\n");
+    }
+    arguments.error = vg_lite_kernel(arguments.command, data);
+
+    if (copy_to_user(arguments.buffer, data, arguments.bytes) != 0)
+        goto error;
+
+    kfree(data);
+
+    if (copy_to_user((void *)arg, &arguments, sizeof(arguments)) != 0)
+        return -1;
+
+    return 0;
+
+error:
+    kfree(data);
+    return -1;
+}
+
+ssize_t drv_read(struct file *file, char *buffer, size_t length, loff_t *offset)
+{
+    struct client_data *private = (struct client_data *)file->private_data;
+
+    if (length != 4)
+        return 0;
+
+    if (copy_to_user((void __user *)buffer, (const void *)&private->device->size, sizeof(private->device->size)) != 0)
+        return 0;
+
+    memcpy(buffer, &private->device->size, 4);
+    return 4;
+}
+
+int drv_mmap(struct file *file, struct vm_area_struct *vm)
+{
+    unsigned long size;
+    struct client_data *private = (struct client_data *)file->private_data;
+
+    return 0;
+
+    if (!cached)
+#if defined(__arm64__) || defined(__aarch64__)
+        vm->vm_page_prot = pgprot_writecombine(vm->vm_page_prot);
+#else
+        vm->vm_page_prot = pgprot_noncached(vm->vm_page_prot);
+#endif
+
+#if KERNEL_VERSION(3, 7, 0) > LINUX_VERSION_CODE
+    vm->vm_flags |= (VM_DONTCOPY | VM_RESERVED);
+#else
+    // FIXME
+    // vm->vm_flags |= (VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP);
+#endif
+    vm->vm_pgoff = 0;
+
+    size = vm->vm_end - vm->vm_start;
+    if (size > private->device->size)
+        size = private->device->size;
+
+    if (remap_pfn_range(vm, vm->vm_start, private->device->physical >> PAGE_SHIFT, size, vm->vm_page_prot) < 0) {
+        printk(KERN_ERR "vg_lite: remap_pfn_range failed\n");
+        return -1;
+    }
+
+    private->vm = vm;
+    private->contiguous_mapped = (void *)vm->vm_start;
+
+    printk(KERN_INFO "vg_lite: mapped %scached contiguous memory to %p\n", cached ? "" : "non-", private->contiguous_mapped);
+
+    return 0;
+}
+
+static const struct file_operations file_operations = {
+    .owner          = THIS_MODULE,
+    .open           = drv_open,
+    .release        = drv_release,
+    .read           = drv_read,
+//#ifdef HAVE_UNLOCKED_IOCTL
+    .unlocked_ioctl = drv_ioctl,
+//#endif
+//#ifdef HAVE_COMPAT_IOCTL
+    .compat_ioctl   = drv_ioctl,
+//#endif
+    .mmap           = drv_mmap,
+};
+
+static int vg_lite_exit(struct platform_device *pdev)
+{
+    /* Check for valid device. */
+    if (device) {
+        if (device->gpu) {
+            /* Unmap the GPU registers. */
+            iounmap(device->gpu);
+            device->gpu = NULL;
+        }
+
+        if (device->pages)
+            /* Free the contiguous memory. */
+            __free_pages(device->pages, device->order);
+
+        if (device->irq_enabled)
+            /* Free the IRQ. */
+            free_irq(platform_get_irq(pdev, 0)/*GPU_IRQ*/, device);
+
+        vg_lite_hal_free_os_heap();
+
+        if (device->created)
+            /* Destroy the device. */
+            device_destroy(device->class, MKDEV(device->major, 0));
+
+        if (device->class)
+            /* Destroy the class. */
+            class_destroy(device->class);
+
+        if (device->registered)
+            /* Unregister the device. */
+            unregister_chrdev(device->major, "vg_lite");
+
+        /* Free up the device structure. */
+        kfree(device);
+    }
+    put_device(&pdev->dev);
+    return 0;
+}
+
+static irqreturn_t irq_handler(int irq, void *context)
+{
+    struct vg_lite_device *device = context;
+
+    /* Read interrupt status. */
+    u32 flags = *(u32 *)((uint8_t *)device->gpu + VG_LITE_INTR_STATUS);
+
+    if (flags) {
+        /* Combine with current interrupt flags. */
+        device->int_flags |= flags;
+
+        /* Wake up any waiters. */
+        wake_up_interruptible(&device->int_queue);
+
+        /* We handled the IRQ. */
+        return IRQ_HANDLED;
+    }
+
+    /* Not our IRQ. */
+    return IRQ_NONE;
+}
+
+static int vg_lite_init(struct platform_device *pdev)
+{
+    struct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    int irq_line = platform_get_irq(pdev, 0);
+    int error = 0;
+    struct device* dev;
+
+    /* Create device structure. */
+    device = kmalloc(sizeof(*device), GFP_KERNEL);
+    if (!device) {
+        printk(KERN_ERR "vg_lite: kmalloc failed\n");
+        return -1;
+    }
+    memset(device, 0, sizeof(struct vg_lite_device));
+    get_device(&pdev->dev);
+    device->dev = &pdev->dev;
+    device->clk = devm_clk_get(&pdev->dev, "vglite");
+    device->reset = devm_reset_control_get(&pdev->dev, NULL);
+    pm_runtime_enable(device->dev);
+
+    /* Map the GPU registers. */
+    device->gpu = ioremap(mem->start, resource_size(mem));
+    if (!device->gpu) {
+        printk(KERN_ERR "vg_lite: ioremap failed %s:%d\n", __func__, __LINE__);
+        kfree(device);
+        return -1;
+    }
+
+    /* Initialize the wait queue. */
+    init_waitqueue_head(&device->int_queue);
+
+    /* Install IRQ. */
+    if (irq_line < 0) {
+        printk(KERN_ERR "vg_lite: platform_get_irq failed, %d\n", irq_line);
+        vg_lite_exit(pdev);
+        return -1;
+    }
+    error = request_irq(irq_line/*GPU_IRQ*/, irq_handler, 0, "vg_lite_irq", device);
+    if (error) {
+        printk(KERN_ERR "vg_lite: request_irq failed, %d\n", error);
+        vg_lite_exit(pdev);
+        return -1;
+    }
+    device->irq_enabled = 1;
+    printk(KERN_DEBUG "vg_lite: enabled ISR for interrupt %d\n", irq_line/*GPU_IRQ*/);
+
+    /* Register device. */
+    device->major = register_chrdev(0, "vg_lite", &file_operations);
+    if (device->major < 0) {
+        printk(KERN_ERR "vg_lite: register_chrdev failed\n");
+        vg_lite_exit(pdev);
+        return -1;
+    }
+    printk(KERN_DEBUG "vg_lite: registered device\n");
+    device->registered = 1;
+
+    /* Create the graphics class. */
+    #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+    device->class = class_create("vg_lite_class");
+    #else
+    device->class = class_create(THIS_MODULE, "vg_lite_class");
+    #endif
+    if (!device->class) {
+        printk(KERN_ERR "vg_lite: class_create failed\n");
+        vg_lite_exit(pdev);
+        return -1;
+    }
+    printk(KERN_DEBUG "vg_lite: created vg_lite_class\n");
+
+    /* Create the device. */
+    dev = device_create(device->class, NULL, MKDEV(device->major, 0), NULL, "vg_lite");
+    if (!dev) {
+        printk(KERN_ERR "vg_lite: device_create failed\n");
+        vg_lite_exit(pdev);
+        return -1;
+    }
+    device->created = 1;
+    printk(KERN_DEBUG "vg_lite: created /dev/vg_lite device\n");
+
+    INIT_LIST_HEAD(&device->dma_list_head);
+    INIT_LIST_HEAD(&device->mapped_list_head);
+    if (dma_set_mask_and_coherent(device->dev, DMA_BIT_MASK(32))) {
+        printk(KERN_ERR "vg_lite: dma_set_coherent_mask failed\n");
+        vg_lite_exit(pdev);
+        return -1;
+    }
+
+    /* Success. */
+    return 0;
+}
+
+static const struct of_device_id gc8000ul_of_match[] = {
+    { .compatible = "verisilicon,gc8000ul" },
+    { /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, gc8000ul_of_match);
+
+module_param(verbose, int, 0600);
+module_param(cached, int, 0600);
+
+static struct platform_driver gc8000ul_platform_driver = {
+    .driver = {
+        .name           = "gc8000ul",
+        .of_match_table = gc8000ul_of_match
+    },
+    .probe              = vg_lite_init,
+    .remove             = vg_lite_exit,
+};
+module_platform_driver(gc8000ul_platform_driver);
diff --git a/drivers/gpu/vglite/vg_lite_hal.h b/drivers/gpu/vglite/vg_lite_hal.h
new file mode 100644
index 000000000..e1b36e6a7
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_hal.h
@@ -0,0 +1,286 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2022 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2022 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_hal_h_
+#define _vg_lite_hal_h_
+
+#define VGLITE_MEM_ALIGNMENT    128
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*!
+ @brief Wait a number of milliseconds.
+
+ @discussion
+ The VGLite hardware requires some waiting when changing clock frequencies or issuing a reset. This is the wrapper function
+ for the delay function.
+
+ @param milliseconds
+ The number of milliseconds to wait.
+ */
+void vg_lite_hal_delay(uint32_t milliseconds);
+
+/*!
+ @brief Initialize the hardware.
+
+ @discussion
+ The VGLite kernel knows how to program its own hardware, but in any SOC there might be additional control required for
+ turning on the power or initializing the clocks. This function gets called by the VGLite kernel before the VGLite graphics
+ hardware gets initialized by the VGLite kernel itself and allows for SOC power management control.
+
+ The implementer should make sure that on exit of this function the power and clock to the VGLite graphics hardware is
+ turned on and stable.
+ */
+void vg_lite_hal_initialize(void);
+
+/*!
+ @brief Uninitialize the hardware.
+
+ @discussion
+ The VGLite kernel knows how to program its own hardware, but in any SOC there might be additional control required for
+ turning off the power or uninitializing the clocks. This function gets called by the VGLite kernel after the VGLite
+ graphics hardware gets uninitialized by the VGLite kernel itself and allows for SOC power management control.
+
+ On exit of this function it is okay to have the power and/or clock to the VGLite graphics hardware turned off.
+ */
+void vg_lite_hal_deinitialize(void);
+
+/*!
+ @brief Allocate contiguous video memory.
+
+ @discussion
+ Any memory the VGLite graphics hardware will see should be allocated as contiguous memory. Any allocated memory will be
+ addressed through an opaque handle, usually a pointer to an opaque structure. The porting layer can put any information it
+ needs inside this structure.
+
+ @param size
+ The number of bytes to allocate.
+
+ @param logical
+ A pointer to a variable that will receive the logical address of the allocated memory for the CPU.
+
+ @param gpu
+ A pointer to a variable that will receive the physical address of the allocated memory for the VGLite graphics hardware.
+
+ @result
+ A pointer to an opaque structure that will be used as the memory handle. NULL should be returned if there is not
+ enough memory.
+ */
+vg_lite_error_t vg_lite_hal_allocate_contiguous(unsigned long size, void ** logical, void ** klogical, uint32_t * physical, void ** node);
+
+/*!
+ @brief Free contiguous video memory.
+
+ @discussion
+ Free the memory allocated by {@link vg_lite_hal_allocate_contiguous}. After this function returns, the associated memory
+ handle is no longer a valid handle.
+
+ @param memory_handle
+ A pointer to an opaque structure returned by {@link vg_lite_hal_allocate_contiguous}.
+ */
+void vg_lite_hal_free_contiguous(void * memory_handle);
+
+/*!
+ @brief remove unfree node when continuously allocate buffer without free buffer.
+
+ @discussion
+ Free the node allocated by {@link kmalloc}. After this function returns, the associated memory
+ handle is no longer a valid handle.
+ */
+void vg_lite_hal_free_os_heap(void);
+
+/*!
+ @brief Map contiguous logical or physical memory into the VGLite graphics hardware space.
+
+ @discussion
+ Any memory, like a frame buffer or some pre-allocated image or path data, needs to be mapped into the VGLite graphics
+ hardware address space and wrapped by a memory handle. This allows the VGLite graphics hardware access that memory
+ directly.
+
+ Either a logical or a physical address should be passed in to map.
+
+ @param size
+ The number of bytes to map.
+
+ @param logical
+ The logical address of the memory region to map or NULL if the logical address is not known.
+
+ @param physical
+ The physical address of the memory region to map if logical is NULL.
+
+ @param gpu
+ A pointer to a variable that will receive the VGLite graphics hardware addressable address of the mapped region.
+
+ @result
+ A pointer to an opaque structure that will be used as the memory handle. NULL should be returned if there is
+ not enough system resources to map the region.
+ */
+void * vg_lite_hal_map(uint32_t flags, uint32_t bytes, void *logical, uint32_t physical, int32_t dma_buf_fd, uint32_t *gpu);
+/*!
+ @brief Unmap a previously mapped region.
+
+ @discussion
+ If a mapped region by {@link vg_lite_hal_map} is no longer needed, it should be unmapped to free up any allocated system
+ resources used when mapping the region.
+
+ @param memory_handle
+ A pointer to an opaque structure returned by {@link vg_lite_hal_map}.
+ */
+void vg_lite_hal_unmap(void * memory_handle);
+
+/*!
+ @brief Execute a memory barrier.
+
+ @discussion
+ Some systems require a a memory barrier to make sure all store operations in the CPU have been handled. This is the wrapper
+ function for a memory barrier.
+ */
+void vg_lite_hal_barrier(void);
+
+/*!
+ @brief Read data from a register from the VGLite graphics hardware.
+
+ @discussion
+ In order to communicate with the VGLite graphics hardware, the kernel needs to read and write to some hardware registers.
+ In each SOC those registers could be allocated at a different space in the physical memory map.
+
+ @param address
+ The relative address of the VGLite graphics hardware register to read from.
+
+ @result
+ The 32-bit value returned from reading the register.
+ */
+uint32_t vg_lite_hal_peek(uint32_t address);
+
+/*!
+ @brief Write data to a register from the VGLite graphics hardware.
+
+ @discussion
+ In order to communicate with the VGLite graphics hardware, the kernel needs to read and write to some hardware registers.
+ In each SOC those registers could be allocated at a different space in the physical memory map.
+
+ @param address
+ The relative address of the VGLite graphics hardware register to write to.
+
+ @param data
+ The data to write to the VGLite graphics hardware register.
+ */
+void vg_lite_hal_poke(uint32_t address, uint32_t data);
+
+/*!
+ @brief query the remaining allocate contiguous video memory.
+
+ @param data
+ The data to get the remaining allocate contiguous video memory bytes.
+ */
+vg_lite_error_t vg_lite_hal_query_mem(vg_lite_kernel_mem_t *mem);
+
+/*!
+ @brief Map contiguous physical memory into the user space.
+
+ @param node
+ This node have 3 attributes, bytes means the number of bytes to map.
+ physical means the physical address of the memory region to map.logical means
+ the return logical address of the memory region after map.
+ */
+vg_lite_error_t vg_lite_hal_map_memory(vg_lite_kernel_map_memory_t *node);
+
+/*!
+ @brief Unmap a previously mapped region.
+
+ @param node
+ This node have 2 attributes, bytes means the number of bytes to unmap.logical means
+ the logical address of the memory region to unmap.
+ */
+vg_lite_error_t vg_lite_hal_unmap_memory(vg_lite_kernel_unmap_memory_t *node);
+
+/*!
+ @brief Wait until an interrupt from the VGLite graphics hardware has been received.
+
+ @discussion
+ Currently, the VGLite API is synchronous. This means that after each call it will wait until the VGLite graphics hardware
+ has completed. The VGLite graphics hardware will send an interrupt when it is finished, and this function will wait until
+ that interrupt has been received by the operating system.
+
+ A timeout value is specified in order if the kernel wants to wait for a specific number of milliseconds fir the interrupt to
+ occur. If the interrupt does not occur in the specified timeout, a timeout error will be returned.
+
+ @param timeout
+ The number of milliseconds to wait for the interrupt before returning a timeout error. If timeout = 0xFFFFFFFF
+ then {@link vg_lite_hal_wait_interrupt} will wait forever for the interrupt.
+
+ @param mask
+ Irq event mask to wait for.
+
+ @result
+ A boolean value indicating whether the interrupt was received (1) or not (0).
+ */
+int32_t vg_lite_hal_wait_interrupt(uint32_t timeout, uint32_t mask, uint32_t * value);
+
+/*!
+ @brief After call vg_lite_hal_map(), flush cpu cache according the direction 
+ spicified by parameter cache_op.
+ */
+vg_lite_error_t vg_lite_hal_operation_cache(void *handle, vg_lite_cache_op_t cache_op);
+
+/*!
+ @brief export memory to dma buf, and get the dma buf fd 
+ */
+vg_lite_error_t vg_lite_hal_memory_export(int32_t *fd);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _vg_lite_hal_h_ */
diff --git a/drivers/gpu/vglite/vg_lite_hw.h b/drivers/gpu/vglite/vg_lite_hw.h
new file mode 100644
index 000000000..7dc7293d6
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_hw.h
@@ -0,0 +1,90 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2022 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2022 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_hw_h
+#define _vg_lite_hw_h
+
+#define VG_LITE_HW_CLOCK_CONTROL    0x000
+#define VG_LITE_HW_IDLE             0x004
+#define VG_LITE_INTR_STATUS         0x010
+#define VG_LITE_INTR_ENABLE         0x014
+#define VG_LITE_HW_CHIP_ID          0x020
+#define VG_LITE_HW_CMDBUF_ADDRESS   0x500
+#define VG_LITE_HW_CMDBUF_SIZE      0x504
+
+#define VG_LITE_EXT_WORK_CONTROL    0x520
+#define VG_LITE_EXT_VIDEO_SIZE      0x524
+#define VG_LITE_EXT_CLEAR_VALUE     0x528
+
+#define VG_LITE_EXT_VIDEO_CONTROL   0x51C
+
+typedef struct clock_control {
+    uint32_t reserved0 : 1;
+    uint32_t clock_gate : 1;
+    uint32_t scale : 7;
+    uint32_t scale_load : 1;
+    uint32_t reserved10 : 2;
+    uint32_t soft_reset : 1;
+    uint32_t reserved13 : 6;
+    uint32_t isolate : 1;
+} clock_control_t;
+
+typedef union vg_lite_hw_clock_control {
+    clock_control_t control;
+    uint32_t        data;
+} vg_lite_hw_clock_control_t;
+
+#define VG_LITE_HW_IDLE_STATE       0x0B05
+
+#endif /* defined(_vg_lite_hw_h) */
diff --git a/drivers/gpu/vglite/vg_lite_ioctl.h b/drivers/gpu/vglite/vg_lite_ioctl.h
new file mode 100644
index 000000000..35d17c14d
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_ioctl.h
@@ -0,0 +1,70 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2020 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2020 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_ioctl_h_
+#define _vg_lite_ioctl_h_
+
+#include "vg_lite_kernel.h"
+
+#define VG_LITE_IOCTL   30000
+
+struct ioctl_data
+{
+    vg_lite_kernel_command_t command;
+    vg_lite_error_t error;
+    unsigned long bytes;
+    void * buffer;
+};
+
+#endif /* _vg_lite_ioctl_h_ */
diff --git a/drivers/gpu/vglite/vg_lite_kernel.c b/drivers/gpu/vglite/vg_lite_kernel.c
new file mode 100644
index 000000000..a5bdaaf72
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_kernel.c
@@ -0,0 +1,861 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2022 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2022 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#include "vg_lite_platform.h"
+#include "vg_lite_kernel.h"
+#include "vg_lite_hal.h"
+#include "vg_lite_hw.h"
+#include "vg_lite_options.h"
+#if defined(__linux__) && !defined(EMULATOR)
+#include <linux/sched.h>
+/*#include <asm/uaccess.h>*/
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#endif
+
+#define FLEXA_TIMEOUT_STATE                 BIT(21)
+#define FLEXA_HANDSHEKE_FAIL_STATE          BIT(22)
+#define MIN_TS_SIZE                         (8 << 10)
+
+#ifdef BACKUP_COMMAND
+typedef struct power_context_command {
+    uint32_t command;
+    uint32_t data;
+}
+power_context_command_t;
+
+static vg_lite_kernel_context_t global_power_context = {0};
+static power_context_command_t *power_context_klogical = NULL;
+#endif
+
+static int s_reference = 0;
+
+static vg_lite_error_t do_terminate(vg_lite_kernel_terminate_t * data);
+
+static void soft_reset(void);
+
+#ifdef BACKUP_COMMAND
+static void execute_recovery_command(uint32_t address, uint32_t size)
+{
+
+    vg_lite_hal_poke(VG_LITE_HW_CMDBUF_ADDRESS, address);
+    vg_lite_hal_poke(VG_LITE_HW_CMDBUF_SIZE, size);
+}
+
+static int check_power_context(int context_index)
+{
+    int ret = -1;
+
+    if (power_context_klogical[context_index].command != 0x80000000) 
+        ret = 1;
+
+    return ret;
+}
+
+static vg_lite_error_t backup_power_context_buffer(uint32_t *command_buffer_klogical, uint32_t size)
+{
+    int index              = 0;
+    int ret                = -1;
+    uint32_t address       = 0;
+    uint32_t context_index = 0; 
+    uint32_t data          = 0;
+
+    if (NULL == command_buffer_klogical) {
+        return VG_LITE_INVALID_ARGUMENT;
+    }
+
+    for (index = 0; index < size; index++) {
+        address = command_buffer_klogical[index];
+
+        if (address == 0x30010A1B) {
+            power_context_klogical[0].data = command_buffer_klogical[index+1];
+            continue;
+        }
+
+        if ((address & 0xFFFF0000) == 0x30010000) {
+            data = command_buffer_klogical[index+1];
+            context_index = address & 0x0000FFFF;
+            ret = check_power_context(context_index);
+            if (-1 != ret) {
+                power_context_klogical[context_index].data    = data;
+            } else {
+                power_context_klogical[context_index].command = address;
+                power_context_klogical[context_index].data    = data;
+            }
+        }
+    }    
+
+    return VG_LITE_SUCCESS;
+}
+#endif
+
+static void gpu(int enable)
+{
+    vg_lite_hw_clock_control_t value;
+    uint32_t          reset_timer = 2;
+    const uint32_t    reset_timer_limit = 1000;
+
+    if (enable) {
+        /* Disable clock gating. */
+        value.data = vg_lite_hal_peek(VG_LITE_HW_CLOCK_CONTROL);
+        value.control.clock_gate = 0;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(1);
+
+        /* Set clock speed. */
+        value.control.scale = 64;
+        value.control.scale_load = 1;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(1);
+        value.control.scale_load = 0;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(5);
+
+        do {
+            /* Perform a soft reset. */
+            soft_reset();
+            vg_lite_hal_delay(reset_timer);
+            reset_timer *= 2;   // If reset failed, try again with a longer wait. Need to check why if dead lopp happens here.
+        } while (!VG_LITE_KERNEL_IS_GPU_IDLE());
+    }
+    else
+    {
+        while (!VG_LITE_KERNEL_IS_GPU_IDLE() && 
+            (reset_timer < reset_timer_limit)   // Force shutdown if timeout.
+            ) {
+            vg_lite_hal_delay(reset_timer);
+            reset_timer *= 2;
+        }
+
+        /* Set idle speed. */
+        value.data = vg_lite_hal_peek(VG_LITE_HW_CLOCK_CONTROL);
+        value.control.scale = 1;
+        value.control.scale_load = 1;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(1);
+        value.control.scale_load = 0;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(5);
+
+        /* Enable clock gating. */
+        value.control.clock_gate = 1;
+        vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+        vg_lite_hal_delay(1);
+    }
+}
+
+/* Initialize some customized modeuls [DDRLess]. */
+static vg_lite_error_t init_3rd(vg_lite_kernel_initialize_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+
+    /* TODO: Init the YUV<->RGB converters. Reserved for SOC. */
+    /* vg_lite_hal_poke(0x00514, data->yuv_pre);
+       vg_lite_hal_poke(0x00518, data->yuv_post);
+     */
+    return error;
+}
+
+static vg_lite_error_t init_vglite(vg_lite_kernel_initialize_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    vg_lite_kernel_context_t * context;
+    int      i;
+
+#if defined(__linux__) && !defined(EMULATOR)
+    vg_lite_kernel_context_t __user * context_usr;
+    vg_lite_kernel_context_t mycontext = { 0 };
+
+    // Construct the context.
+    context_usr = (vg_lite_kernel_context_t  __user *) data->context;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)    
+     if (!access_ok(VERIFY_READ, context_usr, sizeof(*context_usr)) ||
+       !access_ok(VERIFY_WRITE, context_usr, sizeof(*context_usr))) {
+#else
+     if (!access_ok(context_usr, sizeof(*context_usr)) ||
+       !access_ok(context_usr, sizeof(*context_usr))) {
+#endif
+        /* Out of memory. */
+        return VG_LITE_OUT_OF_MEMORY;
+    }
+    context = &mycontext;
+#else
+    // Construct the context.
+    context = data->context;
+    if (context == NULL)
+    {
+        /* Out of memory. */
+        return VG_LITE_OUT_OF_MEMORY;
+    }
+#endif
+
+    /* Zero out all pointers. */
+    for (i = 0; i < CMDBUF_COUNT; i++) {
+        context->command_buffer[i]          = NULL;
+        context->command_buffer_logical[i]  = NULL;
+        context->command_buffer_physical[i] = 0;
+    }
+    context->tess_buffer            = NULL;
+    context->tessbuf_logical    = NULL;
+    context->tessbuf_physical   = 0;
+#ifdef BACKUP_COMMAND
+    global_power_context.power_context_logical = NULL;
+    global_power_context.power_context_klogical = NULL;
+    global_power_context.power_context_physical = 0;
+    global_power_context.power_context = NULL;
+    global_power_context.power_context_capacity = 32 << 10;
+    global_power_context.power_context_size = (VG_LITE_ALIGN(global_power_context.power_context_capacity, VGLITE_MEM_ALIGNMENT) + 7) / 8;
+    printk("global_power_context.power_context_capacity = %d\n", global_power_context.power_context_capacity);
+    printk("global_power_context.power_context_size     = %d\n", global_power_context.power_context_size);
+#endif
+    /* Increment reference counter. */
+    if (s_reference++ == 0) {
+        /* Initialize the SOC. */
+        vg_lite_hal_initialize();
+
+        /* Enable the GPU. */
+        gpu(1);
+    }
+
+    /* Fill in hardware capabilities. */
+    data->capabilities.data = 0;
+
+    /* Allocate the command buffer. */
+    if (data->command_buffer_size) {
+        for (i = 0; i < 2; i ++)
+        {
+            /* Allocate the memory. */
+            error = vg_lite_hal_allocate_contiguous(data->command_buffer_size,
+                                                    &context->command_buffer_logical[i],
+                                                    &context->command_buffer_klogical[i],
+                                                    &context->command_buffer_physical[i],
+                                                    &context->command_buffer[i]);
+            if (error != VG_LITE_SUCCESS) {
+                /* Free any allocated memory. */
+                vg_lite_kernel_terminate_t terminate = { context };
+                do_terminate(&terminate);
+                
+                /* Out of memory. */
+                return error;
+            }
+            
+            /* Return command buffer logical pointer and GPU address. */
+            data->command_buffer[i] = context->command_buffer_logical[i];
+            data->command_buffer_gpu[i] = context->command_buffer_physical[i];
+        }
+    }
+
+#ifdef BACKUP_COMMAND
+    if (global_power_context.power_context_capacity) {
+        /*  Allocate the backup buffer. */
+        error = vg_lite_hal_allocate_contiguous(global_power_context.power_context_capacity,
+                                                &global_power_context.power_context_logical,
+                                                &global_power_context.power_context_klogical,
+                                                &global_power_context.power_context_physical,
+                                                &global_power_context.power_context);
+        if (error != VG_LITE_SUCCESS) {
+            /* Free any allocated memory. */
+            vg_lite_kernel_terminate_t terminate = { &global_power_context };
+            do_terminate(&terminate);
+
+            /* Out of memory. */
+            return error;
+        }
+
+        /* init power context buffer to 0x8000000 */
+        printk("init global power context to NOP command\n");
+        power_context_klogical = (power_context_command_t *)global_power_context.power_context_klogical;
+        for (i = 0; i < global_power_context.power_context_size; i++) { 
+            power_context_klogical[i].command = 0x80000000;
+            power_context_klogical[i].data    = 0x00000000;
+        }
+        power_context_klogical[0].command = 0x30010A1B;
+        power_context_klogical[0].data    = 0x00000001;
+        power_context_klogical[1].command = 0x10000007;
+        power_context_klogical[1].data    = 0x00000000;
+        power_context_klogical[2].command = 0x20000007;
+        power_context_klogical[2].data    = 0x00000000;
+    }
+#endif
+    /* Allocate the tessellation buffer. */
+    if ((data->tess_width > 0) && (data->tess_height > 0)) 
+    {
+        int width = data->tess_width;
+        int height = 0;
+        int vg_countbuffer_size = 0, total_size = 0, ts_buffer_size = 0;
+
+        height = VG_LITE_ALIGN(data->tess_height, 16);
+
+#if (CHIPID==0x355 || CHIPID==0x255)
+        {
+            unsigned long stride, buffer_size, l1_size, l2_size;
+#if (CHIPID==0x355)
+            data->capabilities.cap.l2_cache = 1;
+            width = VG_LITE_ALIGN(width, 128);
+#endif
+            /* Check if we can used tiled tessellation (128x16). */
+            if (((width & 127) == 0) && ((height & 15) == 0)) {
+                data->capabilities.cap.tiled = 0x3;
+            } else {
+                data->capabilities.cap.tiled = 0x2;
+            }
+
+            /* Compute tessellation buffer size. */
+            stride = VG_LITE_ALIGN(width * 8, 64);
+            buffer_size = VG_LITE_ALIGN(stride * height, 64);
+            /* Each bit in the L1 cache represents 64 bytes of tessellation data. */
+            l1_size = VG_LITE_ALIGN(VG_LITE_ALIGN(buffer_size / 64, 64) / 8, 64);
+#if (CHIPID==0x355)
+            /* Each bit in the L2 cache represents 32 bytes of L1 data. */
+            l2_size = VG_LITE_ALIGN(VG_LITE_ALIGN(l1_size / 32, 64) / 8, 64);
+#else
+            l2_size = 0;
+#endif
+            total_size = buffer_size + l1_size + l2_size;
+            ts_buffer_size = buffer_size;
+        }
+#else /* (CHIPID==0x355 || CHIPID==0x255) */
+        {   
+            /* Check if we can used tiled tessellation (128x16). */
+            if (((width & 127) == 0) && ((height & 15) == 0)) {
+                data->capabilities.cap.tiled = 0x3;
+            }
+            else {
+                data->capabilities.cap.tiled = 0x2;
+            }
+
+            vg_countbuffer_size = height * 3;
+            vg_countbuffer_size = VG_LITE_ALIGN(vg_countbuffer_size, 64);
+            total_size = height * 128;
+            if (total_size < MIN_TS_SIZE)
+                total_size = MIN_TS_SIZE;
+            ts_buffer_size = total_size - vg_countbuffer_size;
+        }
+#endif /* (CHIPID==0x355 || CHIPID==0x255) */
+
+        /* Allocate the memory. */
+        error = vg_lite_hal_allocate_contiguous(total_size,
+                                                &context->tessbuf_logical,
+                                                &context->tessbuf_klogical,
+                                                &context->tessbuf_physical,
+                                                &context->tess_buffer);
+        if (error != VG_LITE_SUCCESS) {
+            /* Free any allocated memory. */
+            vg_lite_kernel_terminate_t terminate = { context };
+            do_terminate(&terminate);
+            return error;
+        }
+
+        /* Return the tessellation buffer pointers and GPU addresses. */
+        data->physical_addr = context->tessbuf_physical;
+        data->logical_addr = (uint8_t *)context->tessbuf_logical;
+        data->tessbuf_size = ts_buffer_size;
+        data->countbuf_size = vg_countbuffer_size;
+        data->tess_w_h = width | (height << 16);
+    }
+
+    /* Enable all interrupts. */
+    vg_lite_hal_poke(VG_LITE_INTR_ENABLE, 0xFFFFFFFF);
+
+#if defined(__linux__) && !defined(EMULATOR)
+    if (copy_to_user(context_usr, context, sizeof(vg_lite_kernel_context_t)) != 0) {
+      // Free any allocated memory.
+      vg_lite_kernel_terminate_t terminate = { context };
+      do_terminate(&terminate);
+
+      return VG_LITE_NO_CONTEXT;
+    }
+#endif
+    return error;
+}
+
+static vg_lite_error_t do_initialize(vg_lite_kernel_initialize_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    /* Free any allocated memory for the context. */
+    do {
+        error = init_vglite(data);
+        if (error != VG_LITE_SUCCESS)
+            break;
+
+        error = init_3rd(data);
+        if (error != VG_LITE_SUCCESS)
+            break;
+    } while (0);
+
+    return error;
+}
+
+static vg_lite_error_t terminate_vglite(vg_lite_kernel_terminate_t * data)
+{
+    vg_lite_kernel_context_t *context = NULL;
+#if defined(__linux__) && !defined(EMULATOR)
+    vg_lite_kernel_context_t mycontext = {0};
+    if (copy_from_user(&mycontext, data->context, sizeof(vg_lite_kernel_context_t)) != 0) {
+      return VG_LITE_NO_CONTEXT;
+    }
+    context = &mycontext;
+#else
+    context = data->context;
+#endif
+
+    /* Free any allocated memory for the context. */
+    if (context->command_buffer[0]) {
+        /* Free the command buffer. */
+        vg_lite_hal_free_contiguous(context->command_buffer[0]);
+        context->command_buffer[0] = NULL;
+    }
+
+    if (context->command_buffer[1]) {
+        /* Free the command buffer. */
+        vg_lite_hal_free_contiguous(context->command_buffer[1]);
+        context->command_buffer[1] = NULL;
+    }
+
+#ifdef BACKUP_COMMAND
+    if (global_power_context.power_context) {
+        /* Free the power context. */
+        vg_lite_hal_free_contiguous(global_power_context.power_context);
+        global_power_context.power_context = NULL;
+    }
+#endif
+    if (context->tess_buffer) {
+        /* Free the tessellation buffer. */
+        vg_lite_hal_free_contiguous(context->tess_buffer);
+        context->tess_buffer = NULL;
+    }
+    vg_lite_hal_free_os_heap();
+    /* Decrement reference counter. */
+    if (--s_reference == 0) {
+        /* Disable the GPU. */
+        gpu(0);
+
+        /* De-initialize the SOC. */
+        vg_lite_hal_deinitialize();
+    }
+
+#if defined(__linux__) && !defined(EMULATOR)
+    if (copy_to_user((vg_lite_kernel_context_t  __user *) data->context,
+        &mycontext, sizeof(vg_lite_kernel_context_t)) != 0) {
+            return VG_LITE_NO_CONTEXT;
+    }
+#endif
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t terminate_3rd(vg_lite_kernel_terminate_t * data)
+{
+    /* TODO: Terminate the converters. */
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_terminate(vg_lite_kernel_terminate_t * data)
+{
+    terminate_vglite(data);
+    terminate_3rd(data);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_allocate(vg_lite_kernel_allocate_t * data)
+{
+    vg_lite_error_t error;
+    error = vg_lite_hal_allocate_contiguous(data->bytes, &data->memory, &data->kmemory, &data->memory_gpu, &data->memory_handle);
+    return error;
+}
+
+static vg_lite_error_t do_free(vg_lite_kernel_free_t * data)
+{
+    vg_lite_hal_free_contiguous(data->memory_handle);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_submit(vg_lite_kernel_submit_t * data)
+{
+    uint32_t offset;
+    vg_lite_kernel_context_t *context = NULL;
+    uint32_t physical = data->context->command_buffer_physical[data->command_id];
+
+#if defined(__linux__) && !defined(EMULATOR)
+    vg_lite_kernel_context_t mycontext = { 0 };
+
+    if (copy_from_user(&mycontext, data->context, sizeof(vg_lite_kernel_context_t)) != 0) {
+      return VG_LITE_NO_CONTEXT;
+    }
+    context = &mycontext;
+    physical = context->command_buffer_physical[data->command_id];
+#else
+    context = data->context;
+    if (context == NULL)
+    {
+        return VG_LITE_NO_CONTEXT;
+    }
+#endif
+    /* Perform a memory barrier. */
+    vg_lite_hal_barrier();
+
+    offset = (uint8_t *) data->commands - (uint8_t *)context->command_buffer_logical[data->command_id];
+
+#ifdef BACKUP_COMMAND
+    backup_power_context_buffer((uint32_t *)((uint8_t *)context->command_buffer_klogical[data->command_id] + offset), (data->command_size + 3) / 4);
+#endif
+    /* Write the registers to kick off the command execution (CMDBUF_SIZE). */
+    vg_lite_hal_poke(VG_LITE_HW_CMDBUF_ADDRESS, physical + offset);
+    vg_lite_hal_poke(VG_LITE_HW_CMDBUF_SIZE, (data->command_size + 7) / 8);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_wait(vg_lite_kernel_wait_t * data)
+{
+    /* Wait for interrupt. */
+    if (!vg_lite_hal_wait_interrupt(data->timeout_ms, data->event_mask, &data->event_got)) {
+        /* Timeout. */
+        return VG_LITE_TIMEOUT;
+    }
+
+#if gcFEATURE_VG_FLEXA
+    if (data->event_got & FLEXA_TIMEOUT_STATE)
+        return VG_LITE_FLEXA_TIME_OUT;
+
+    if (data->event_got & FLEXA_HANDSHEKE_FAIL_STATE)
+        return VG_LITE_FLEXA_HANDSHAKE_FAIL;
+#endif
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_reset(void)
+{
+#ifdef BACKUP_COMMAND
+    int i = 0;
+    vg_lite_kernel_wait_t wait;
+    vg_lite_error_t error;
+
+    wait.timeout_ms = 2000;
+    wait.event_mask = (uint32_t)~0;
+#endif
+    /* Disable and enable the GPU. */
+    gpu(1);
+    vg_lite_hal_poke(VG_LITE_INTR_ENABLE, 0xFFFFFFFF);
+    
+#ifdef BACKUP_COMMAND
+    power_context_klogical[0x00000AD2].command = 0x00000000;
+    power_context_klogical[0x00000AD2].data    = 0x00000000;
+
+    printk("after resume and the global_power_context command buffer is : \n");
+
+    for (i = 0; i < 0x00000AD3; i++) {
+        if (power_context_klogical[i].command != 0x80000000)
+            printk("global_power_context command = %08x, global_power_context data = %08x\n", 
+                    power_context_klogical[i].command, power_context_klogical[i].data);
+    }
+
+    execute_recovery_command(global_power_context.power_context_physical, 0x00000AD3);
+
+    error = do_wait(&wait);
+
+    printk("execute_recovery_command success!\n");
+#endif
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_gpu_close(void)
+{
+    gpu(0);
+
+#ifdef BACKUP_COMMAND
+    printk("gpu is shutdown!\n");
+#endif
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_debug(void)
+{
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_map(vg_lite_kernel_map_t * data)
+{
+    data->memory_handle = vg_lite_hal_map(data->flags, data->bytes, data->logical, data->physical, data->dma_buf_fd, &data->memory_gpu);
+    if (data->memory_handle == NULL)
+    {
+        return VG_LITE_OUT_OF_RESOURCES;
+    }
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_unmap(vg_lite_kernel_unmap_t * data)
+{
+    vg_lite_hal_unmap(data->memory_handle);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_peek(vg_lite_kernel_info_t * data)
+{
+    data->reg = vg_lite_hal_peek(data->addr);
+
+    return VG_LITE_SUCCESS;
+}
+
+#if gcFEATURE_VG_FLEXA
+static vg_lite_error_t do_flexa_enable(vg_lite_kernel_flexa_info_t * data)
+{
+    /* reset all flexa states */
+    vg_lite_hal_poke(0x03600, 0x0);
+    /* set sync mode */
+    vg_lite_hal_poke(0x03604, data->segment_address);
+
+    vg_lite_hal_poke(0x03608, data->segment_count);
+
+    vg_lite_hal_poke(0x0360C, data->segment_size);
+
+    vg_lite_hal_poke(0x0520, data->sync_mode);
+
+    vg_lite_hal_poke(0x03610, data->stream_id | data->sbi_mode | data->start_flag | data->stop_flag | data->reset_flag);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_flexa_set_background_address(vg_lite_kernel_flexa_info_t * data)
+{
+    vg_lite_hal_poke(0x03604, data->segment_address);
+
+    vg_lite_hal_poke(0x03608, data->segment_count);
+
+    vg_lite_hal_poke(0x0360C, data->segment_size);
+
+    vg_lite_hal_poke(0x03610, data->stream_id | data->sbi_mode | data->start_flag | data->stop_flag | data->reset_flag);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_flexa_disable(vg_lite_kernel_flexa_info_t * data)
+{
+
+    vg_lite_hal_poke(0x0520, data->sync_mode);
+
+    vg_lite_hal_poke(0x03610, data->stream_id | data->sbi_mode);
+
+    /* reset all flexa states */
+    vg_lite_hal_poke(0x03600, 0x0);
+
+    return VG_LITE_SUCCESS;
+}
+
+static vg_lite_error_t do_flexa_stop_frame(vg_lite_kernel_flexa_info_t * data)
+{
+    vg_lite_hal_poke(0x03610, data->stream_id | data->sbi_mode | data->start_flag | data->stop_flag | data->reset_flag);
+
+    return VG_LITE_SUCCESS;
+}
+#endif
+
+static vg_lite_error_t do_query_mem(vg_lite_kernel_mem_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    error = vg_lite_hal_query_mem(data);
+
+    return error;
+}
+
+static vg_lite_error_t do_map_memory(vg_lite_kernel_map_memory_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    error = vg_lite_hal_map_memory(data);
+
+    return error;
+}
+
+static vg_lite_error_t do_unmap_memory(vg_lite_kernel_unmap_memory_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    error = vg_lite_hal_unmap_memory(data);
+
+    return error;
+}
+
+static vg_lite_error_t do_cache(vg_lite_kernel_cache_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+    error = vg_lite_hal_operation_cache(data->memory_handle, data->cache_op);
+
+    return error;
+}
+
+static vg_lite_error_t do_export_memory(vg_lite_kernel_export_memory_t * data)
+{
+    vg_lite_error_t error = VG_LITE_SUCCESS;
+
+    error = vg_lite_hal_memory_export(&data->fd); 
+
+    return error;
+}
+
+static void soft_reset(void)
+{
+    vg_lite_hw_clock_control_t value;
+    value.data = vg_lite_hal_peek(VG_LITE_HW_CLOCK_CONTROL);
+
+    /* Perform a soft reset. */
+    value.control.isolate = 1;
+    vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+    value.control.soft_reset = 1;
+    vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+    vg_lite_hal_delay(5);
+    value.control.soft_reset = 0;
+    vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+    value.control.isolate = 0;
+    vg_lite_hal_poke(VG_LITE_HW_CLOCK_CONTROL, value.data);
+}
+
+vg_lite_error_t vg_lite_kernel(vg_lite_kernel_command_t command, void * data)
+{
+    /* Dispatch on command. */
+    switch (command) {
+        case VG_LITE_INITIALIZE:
+            /* Initialize the context. */
+            return do_initialize(data);
+
+        case VG_LITE_TERMINATE:
+            /* Terminate the context. */
+            return do_terminate(data);
+
+        case VG_LITE_ALLOCATE:
+            /* Allocate contiguous memory. */
+            return do_allocate(data);
+
+        case VG_LITE_FREE:
+            /* Free contiguous memory. */
+            return do_free(data);
+
+        case VG_LITE_SUBMIT:
+            /* Submit a command buffer. */
+            return do_submit(data);
+
+        case VG_LITE_WAIT:
+            /* Wait for the GPU. */
+            return do_wait(data);
+
+        case VG_LITE_RESET:
+            /* Reset the GPU. */
+            return do_reset();
+            
+        case VG_LITE_DEBUG:
+            /* Perform debugging features. */
+            return do_debug();
+
+        case VG_LITE_MAP:
+            /* Map some memory. */
+            return do_map(data);
+
+        case VG_LITE_UNMAP:
+            /* Unmap some memory. */
+            return do_unmap(data);
+
+            /* Get register info. */
+        case VG_LITE_CHECK:
+            /* Get register value. */
+            return do_peek(data);
+
+#if gcFEATURE_VG_FLEXA
+        case VG_LITE_FLEXA_DISABLE:
+            /* Write register value. */
+            return do_flexa_disable(data);
+
+        case VG_LITE_FLEXA_ENABLE:
+            /* Write register value. */
+            return do_flexa_enable(data);
+
+        case VG_LITE_FLEXA_STOP_FRAME:
+            /* Write register value. */
+            return do_flexa_stop_frame(data);
+
+        case VG_LITE_FLEXA_SET_BACKGROUND_ADDRESS:
+            /* Write register value. */
+            return do_flexa_set_background_address(data);
+#endif
+
+        case VG_LITE_QUERY_MEM:
+            return do_query_mem(data);
+
+        case VG_LITE_MAP_MEMORY:
+            /* Map memory to user */
+            return do_map_memory(data);
+
+        case VG_LITE_UNMAP_MEMORY:
+            /* Unmap memory to user */
+            return do_unmap_memory(data);
+
+        case VG_LITE_CLOSE:
+            return do_gpu_close();
+
+        case VG_LITE_CACHE:
+            return do_cache(data);
+
+        case VG_LITE_EXPORT_MEMORY:
+            return do_export_memory(data);
+
+        default:
+            break;
+    }
+
+    /* Invalid command. */
+    return VG_LITE_INVALID_ARGUMENT;
+}
diff --git a/drivers/gpu/vglite/vg_lite_kernel.h b/drivers/gpu/vglite/vg_lite_kernel.h
new file mode 100644
index 000000000..fb1c48859
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_kernel.h
@@ -0,0 +1,525 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2022 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2022 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_kernel_h_
+#define _vg_lite_kernel_h_
+
+/* Interrupt IDs from GPU. */
+#define EVENT_UNEXPECTED_MESH  0x80000000
+#define EVENT_CMD_BAD_WRITE    0x40000000
+#define EVENT_ERROR_RECOVER    0x20000000
+#define EVENT_CMD_SWITCH       0x10000000
+#define EVENT_MCU_BAD_WRITE    0x08000000
+#define EVENT_END              0
+
+#define MAX_CONTIGUOUS_SIZE 0x02000000
+
+#define VG_LITE_INFINITE    0xFFFFFFFF
+#define CMDBUF_COUNT        2
+
+#define VG_LITE_ALIGN(number, alignment)    \
+        (((number) + ((alignment) - 1)) & ~((alignment) - 1))
+
+#ifndef  BIT
+#define  BIT(x)                 (1 << x)
+#endif
+
+#define VG_LITE_KERNEL_IS_GPU_IDLE() \
+((vg_lite_hal_peek(VG_LITE_HW_IDLE) & VG_LITE_HW_IDLE_STATE) == VG_LITE_HW_IDLE_STATE)
+
+/* Hardware chip Ids */
+#define GPU_CHIP_ID_GCNANOLITEV         0x255
+#define GPU_CHIP_ID_GC355               0x355
+#define GPU_CHIP_ID_GCNANOULTRAV        0x265
+
+/* vg_lite_kernel_map_t flag type */
+#define VG_LITE_HAL_MAP_DMABUF          0x00000004
+#define VG_LITE_HAL_MAP_USER_MEMORY     0x00000008
+
+/* vg_lite_kernel_allocate_t flag type */
+#define VG_LITE_RESERVED_ALLOCATOR      0x10000000
+#define VG_LITE_GFP_ALLOCATOR           0x20000000
+#define VG_LITE_DMA_ALLOCATOR           0x40000000
+#define VG_LITE_MEMORY_ALLOCATOR_FLAG   0x70000000
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef VG_LITE_ERROR
+#define VG_LITE_ERROR  1
+/*!
+    @abstract Error codes that the vg_lite functions can return.
+
+    @discussion
+    All API functions return a status code. On success, VG_LITE_SUCCESS will be returned when a function is
+    successful. This value is set to zero, so if any function returns a non-zero value, an error has occurred.
+    */
+typedef enum vg_lite_error
+{
+    VG_LITE_SUCCESS = 0,          /*! Success.                                         */
+    VG_LITE_INVALID_ARGUMENT,     /*! An invalid argument was specified.               */
+    VG_LITE_OUT_OF_MEMORY,        /*! Out of memory.                                   */
+    VG_LITE_NO_CONTEXT,           /*! No context or an unintialized context specified. */
+    VG_LITE_TIMEOUT,              /*! A timeout has occurred during a wait.            */
+    VG_LITE_OUT_OF_RESOURCES,     /*! Out of system resources.                         */
+    VG_LITE_GENERIC_IO,           /*! Cannot communicate with the kernel driver.       */
+    VG_LITE_NOT_SUPPORT,          /*! Function call not supported.                     */
+    VG_LITE_ALREADY_EXISTS,       /*! Object already exists                            */
+    VG_LITE_NOT_ALIGNED,          /*! Data alignment error                             */
+    VG_LITE_FLEXA_TIME_OUT,       /*! VG timeout requesting for segment buffer         */
+    VG_LITE_FLEXA_HANDSHAKE_FAIL, /*! VG and SBI synchronizer handshake failed         */
+    VG_LITE_SYSTEM_CALL_FAIL,     /*! kernel api call fail                             */
+}
+vg_lite_error_t;
+#endif
+
+typedef enum vg_lite_kernel_counter
+{
+    /* Dont't touch the counter. */
+    VG_LITE_NONE,
+
+    /* Turn the counter on. */
+    VG_LITE_ON,
+
+    /* Turn the counter off. */
+    VG_LITE_OFF,
+
+    /* Query the counter and reset its values. */
+    VG_LITE_QUERY,
+}
+vg_lite_kernel_counter_t;
+
+typedef enum vg_lite_kernel_command
+{
+    /* Initialize the GPU. */
+    VG_LITE_INITIALIZE,
+
+    /* Terminate the GPU. */
+    VG_LITE_TERMINATE,
+
+    /* Allocate memory. */
+    VG_LITE_ALLOCATE,
+
+    /* Free memory. */
+    VG_LITE_FREE,
+
+    /* Submit a command buffer to the GPU. */
+    VG_LITE_SUBMIT,
+
+    /* Wait for the GPU to be completed. */
+    VG_LITE_WAIT,
+
+    /* Reset the GPU. */
+    VG_LITE_RESET,
+
+    /* Debug commands. */
+    VG_LITE_DEBUG,
+
+    /* Map memory. */
+    VG_LITE_MAP,
+
+    /* Unmap memory. */
+    VG_LITE_UNMAP,
+
+    /* Check info. */
+    VG_LITE_CHECK,
+
+    /* Query mem. */
+    VG_LITE_QUERY_MEM,
+
+    /* Flexa disable */
+    VG_LITE_FLEXA_DISABLE,
+
+    /* Flexa enable */
+    VG_LITE_FLEXA_ENABLE,
+
+    /* Flexa stop frame */
+    VG_LITE_FLEXA_STOP_FRAME,
+
+    /* Set background address */
+    VG_LITE_FLEXA_SET_BACKGROUND_ADDRESS,
+
+    /* Map memory to user */
+    VG_LITE_MAP_MEMORY,
+
+    /* Unmap memory to user */
+    VG_LITE_UNMAP_MEMORY,
+
+    /* Close gpu */
+    VG_LITE_CLOSE,
+
+    /* Operation cache */
+    VG_LITE_CACHE,
+
+    /* Export memory */
+    VG_LITE_EXPORT_MEMORY,
+}
+vg_lite_kernel_command_t;
+
+typedef enum vg_lite_cache_op {
+    VG_LITE_CACHE_CLEAN,
+    VG_LITE_CACHE_INVALIDATE,
+    VG_LITE_CACHE_FLUSH,
+} 
+vg_lite_cache_op_t;
+
+struct vg_lite_kernel_context {
+    /* Command buffer. */
+    void                     *command_buffer[CMDBUF_COUNT];
+    void                     *command_buffer_logical[CMDBUF_COUNT];
+    void                     *command_buffer_klogical[CMDBUF_COUNT];
+    uint32_t                  command_buffer_physical[CMDBUF_COUNT];
+    
+    /* Tessellation buffer. */
+    void                     *tess_buffer;
+    void                     *tessbuf_logical;
+    void                     *tessbuf_klogical;
+    uint32_t                  tessbuf_physical;
+
+    /* power context buffer  */
+    void                     *power_context;
+    void                     *power_context_logical;
+    void                     *power_context_klogical;
+    uint32_t                  power_context_physical;
+    uint32_t                  power_context_size;
+    uint32_t                  power_context_capacity;
+};
+    
+/* Context structure. */
+typedef struct vg_lite_kernel_context vg_lite_kernel_context_t;
+
+typedef struct capabilities
+{
+    uint32_t tiled : 2;
+    uint32_t l2_cache : 1;
+}
+capabilities_t;
+    
+typedef union vg_lite_capabilities
+{
+    capabilities_t cap;
+    uint32_t       data;
+}
+vg_lite_capabilities_t;
+
+typedef struct vg_lite_kernel_initialize
+{
+    /* Command buffer size. */
+    uint32_t command_buffer_size;
+
+    /* Tessellation buffer width. */
+    int32_t tess_width;
+
+    /* Tessellation buffer height. */
+    int32_t tess_height;
+
+    /* OUTPUT */
+
+    /* Context pointer. */
+    vg_lite_kernel_context_t * context;
+
+    /* Capabilities. */
+    vg_lite_capabilities_t capabilities;
+
+    /* Allocated command buffer. */
+    void * command_buffer[CMDBUF_COUNT];
+    
+    /* GPU address for command buffer. */
+    uint32_t command_buffer_gpu[CMDBUF_COUNT];
+    
+    /* GPU addresses for tesselation buffers. */
+    uint32_t physical_addr;
+    
+    /* Logic addresses for tessellation buffers: used by SW Tessellator. */
+    uint8_t *logical_addr;
+    
+    /* Size of each level of the tesselation buffer. */
+    uint32_t tessbuf_size;
+
+    /* Size of each level of the vg count buffer. */
+    uint32_t countbuf_size;
+
+    /* Width and height of tessellation buffer. */
+    uint32_t tess_w_h;
+}
+vg_lite_kernel_initialize_t;
+
+typedef struct vg_lite_kernel_terminate
+{
+    /* Context to terminate. */
+    vg_lite_kernel_context_t * context;
+}
+vg_lite_kernel_terminate_t;
+
+typedef struct vg_lite_kernel_allocate
+{
+    /* INPUT */
+
+    /* Number of bytes to allocate. */
+    uint32_t bytes;
+
+    /* Flag to indicate whether the allocated memory is contiguous or not. */
+    int32_t contiguous;
+
+    /* Flag to indicate where to allocate memory  */
+    uint32_t flags;
+
+    /* OUTPUT */
+
+    /* Memory handle. */
+    void * memory_handle;
+
+    /* Allocated memory. */
+    void * memory;
+
+    /* kernel memory */
+    void * kmemory;
+
+    /* GPU address of allocated memory. */
+    uint32_t memory_gpu;
+}
+vg_lite_kernel_allocate_t;
+
+typedef struct vg_lite_kernel_free
+{
+    /* Memory handle to free. */
+    void * memory_handle;
+}
+vg_lite_kernel_free_t;
+
+typedef struct vg_lite_kernel_submit
+{
+    /* Context to submit to. */
+    vg_lite_kernel_context_t * context;
+
+    /* Pointer to command buffer. */
+    void * commands;
+
+    /* Number of bytes in command buffer. */
+    uint32_t command_size;
+
+    /* Command Buffer ID. */
+    uint32_t command_id;
+}
+vg_lite_kernel_submit_t;
+
+typedef struct vg_lite_kernel_wait
+{
+    /* Context to wait for. */
+    vg_lite_kernel_context_t * context;
+
+    /* Timeout in milliseconds. */
+    uint32_t timeout_ms;
+    
+    /* The event to wait. */
+    uint32_t event_mask;
+
+    /* The event(s) got after waiting. */
+    uint32_t event_got;
+}
+vg_lite_kernel_wait_t;
+
+typedef struct vg_lite_kernel_reset
+{
+    /* Context to reset. */
+    vg_lite_kernel_context_t * context;
+}
+vg_lite_kernel_reset_t;
+
+typedef struct vg_lite_kernel_debug
+{
+    /* Context to debug. */
+    vg_lite_kernel_context_t * context;
+
+    /* Bandwidth counter enabler. */
+    vg_lite_kernel_counter_t bandwidth_counter;
+
+    /* Pixel counter enabler. */
+    vg_lite_kernel_counter_t pixel_counters;
+
+    /* OUTPUT */
+
+    /* Bandwidth counters:
+     *  [0] - burst of 8.
+     *  [1] - burst of 16.
+     *  [2] - burst of 32.
+     *  [3] - burst of 64.
+     */
+    uint32_t bandwidth[4];
+
+    /* Pixel counters:.
+     *  [0] - Number of tessellated pixels.
+     *  [1] - Number of imaged pixels.
+     *  [2] - Number of rendered pixels.
+     */
+    uint32_t pixels[3];
+}
+vg_lite_kernel_debug_t;
+
+typedef struct vg_lite_kernel_map
+{
+    /* INPUT */  
+    uint32_t flags;
+
+    /* user memory */
+    /* Number of bytes to map. */
+    uint32_t bytes;
+
+    /* Logical memory address or NULL. */
+    void * logical;
+
+    /* Physical memory address or 0. */
+    uint32_t physical;
+
+    /* dma_buf */
+    /* dma_buf fd */
+    int32_t dma_buf_fd;
+
+    /* OUTPUT */
+    /* Memory handle for mapped memory. */
+    void * memory_handle;
+
+    /* GPU address of mapped memory. */
+    uint32_t memory_gpu;
+}
+vg_lite_kernel_map_t;
+
+typedef struct vg_lite_kernel_unmap
+{
+    /* Memory handle to unmap. */
+    void * memory_handle;
+}
+vg_lite_kernel_unmap_t;
+
+typedef struct vg_lite_kernel_cache
+{
+    vg_lite_cache_op_t cache_op;    
+
+    /* Memory handle to operation. */
+    void * memory_handle;
+}
+vg_lite_kernel_cache_t;
+
+typedef struct vg_lite_kernel_info
+{
+    /* Register's address. */
+    uint32_t addr;
+
+    /* Check register info. */
+    uint32_t reg;
+}
+vg_lite_kernel_info_t;
+
+typedef struct vg_lite_kernel_flexa_info
+{
+    uint32_t                    sbi_mode;
+    uint32_t                    sync_mode;
+    uint32_t                    flexa_mode;
+    uint32_t                    stream_id;
+    uint32_t                    segment_address;
+    uint32_t                    segment_count;
+    uint32_t                    segment_size;
+    uint32_t                    stop_flag;
+    uint32_t                    start_flag;
+    uint32_t                    reset_flag;
+} vg_lite_kernel_flexa_info_t;
+
+typedef struct vg_lite_kernel_mem
+{
+    uint32_t bytes;
+}
+vg_lite_kernel_mem_t;
+
+typedef struct vg_lite_kernel_map_memory
+{
+    /* Number of bytes to map. */
+    uint32_t bytes;
+
+    /* Physical memory address. */
+    uint32_t physical;
+
+    /* Logical memory address. */
+    void * logical;
+}
+vg_lite_kernel_map_memory_t;
+
+typedef struct vg_lite_kernel_unmap_memory
+{
+    /* Number of bytes to map. */
+    uint32_t bytes;
+
+    /* Logical memory address. */
+    void * logical;
+}
+vg_lite_kernel_unmap_memory_t;
+
+typedef struct vg_lite_kernel_close
+{
+    vg_lite_kernel_context_t * context;
+}
+vg_lite_kernel_close_t;
+
+typedef struct vg_lite_kernel_export_memory
+{
+    int32_t fd;
+}
+vg_lite_kernel_export_memory_t;
+
+vg_lite_error_t vg_lite_kernel(vg_lite_kernel_command_t command, void * data);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif /* _vg_lite_kernel_h_ */
diff --git a/drivers/gpu/vglite/vg_lite_options.h b/drivers/gpu/vglite/vg_lite_options.h
new file mode 100644
index 000000000..3264e8534
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_options.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+*
+*    Copyright 2012 - 2022 Vivante Corporation, Santa Clara, California.
+*    All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _vg_lite_options_h_
+#define _vg_lite_options_h_
+
+#define CHIPID          0x265
+#define REVISION        0x1003
+#define CID             0x417
+
+#define gcFEATURE_VG_IM_INDEX_FORMAT    1
+#define gcFEATURE_VG_SCISSOR    1
+#define gcFEATURE_VG_BORDER_CULLING    1
+#define gcFEATURE_VG_RGBA2_FORMAT    1
+#define gcFEATURE_VG_QUALITY_8X    0
+#define gcFEATURE_VG_IM_FASTCLEAR    0
+#define gcFEATURE_VG_RADIAL_GRADIENT    0
+#define gcFEATURE_VG_GLOBAL_ALPHA    1
+#define gcFEATURE_VG_RGBA8_ETC2_EAC    1
+#define gcFEATURE_VG_COLOR_KEY    0
+#define gcFEATURE_VG_DOUBLE_IMAGE    0
+#define gcFEATURE_VG_YUV_OUTPUT    0
+#define gcFEATURE_VG_FLEXA    0
+#define gcFEATURE_VG_24BIT    0
+#define gcFEATURE_VG_DITHER    0
+#define gcFEATURE_VG_USE_DST    0
+#define gcFEATURE_VG_PE_CLEAR    1
+#define gcFEATURE_VG_IM_INPUT    1
+#define gcFEATURE_VG_DEC_COMPRESS    0
+#define gcFEATURE_VG_LINEAR_GRADIENT_EXT    0
+#define gcFEATURE_VG_MASK    0
+#define gcFEATURE_VG_MIRROR    0
+#define gcFEATURE_VG_GAMMA    0
+#define gcFEATURE_VG_NEW_BLEND_MODE    0
+#define gcFEATURE_VG_STENCIL    0
+#define gcFEATURE_VG_SRC_PREMULTIPLIED    1
+#define gcFEATURE_VG_HW_PREMULTIPLY    0
+#define gcFEATURE_VG_COLOR_TRANSFORMATION    0
+#define gcFEATURE_VG_LVGL_SUPPORT    0
+#define gcFEATURE_VG_INDEX_ENDIAN    0
+#define gcFEATURE_VG_24BIT_PLANAR    0
+#define gcFEATURE_VG_PIXEL_MATRIX    0
+#define gcFEATURE_VG_NEW_IMAGE_INDEX    0
+#define gcFEATURE_VG_PARALLEL_PATHS    0
+#define gcFEATURE_VG_STRIPE_MODE    0
+#define gcFEATURE_VG_IM_DEC_INPUT    0
+#define gcFEATURE_VG_GAUSSIAN_BLUR    0
+#define gcFEATURE_VG_RECTANGLE_TILED_OUT    1
+#define gcFEATURE_VG_TESSELLATION_TILED_OUT    1
+#define gcFEATURE_VG_IM_REPEAT_REFLECT    0
+#define gcFEATURE_VG_YUY2_INPUT    1
+#define gcFEATURE_VG_YUV_INPUT    0
+#define gcFEATURE_VG_YUV_TILED_INPUT    0
+#define gcFEATURE_VG_AYUV_INPUT    0
+#define gcFEATURE_VG_16PIXELS_ALIGNED    1
+
+/* SW Features */
+#define gcFEATURE_VG_STROKE_PATH    1
+#define gcFEATURE_VG_ARC_PATH    1
+#define gcFEATURE_VG_ERROR_CHECK    1
+#define gcFEATURE_VG_TRACE_API    0
+#endif
diff --git a/drivers/gpu/vglite/vg_lite_platform.h b/drivers/gpu/vglite/vg_lite_platform.h
new file mode 100644
index 000000000..145040412
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_platform.h
@@ -0,0 +1,57 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2020 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2020 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
diff --git a/drivers/gpu/vglite/vg_lite_type.h b/drivers/gpu/vglite/vg_lite_type.h
new file mode 100644
index 000000000..0d7f6c4d4
--- /dev/null
+++ b/drivers/gpu/vglite/vg_lite_type.h
@@ -0,0 +1,74 @@
+/*****************************************************************************
+*
+*    copyright 2012 - 2023 Vivante Corporation, Santa Clara, California.
+*    All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#ifndef _vg_lite_type_h_
+#define _vg_lite_type_h_
+
+#include <asm/bitsperlong.h>
+#include "vg_lite_kernel.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VG_FALSE                   0
+#define VG_TRUE                    1
+
+#define VG_SUCCESS                 0
+#define VG_FAIL                   -1
+
+typedef int                 vg_lite_bool_t;
+typedef unsigned char       vg_lite_uint8_t;
+typedef char                vg_lite_int8_t;
+typedef short               vg_lite_int16_t;
+typedef unsigned short      vg_lite_uint16_t;
+typedef int                 vg_lite_int32_t;
+typedef unsigned int        vg_lite_uint32_t;
+typedef unsigned long long  vg_lite_uint64_t;
+typedef float               vg_lite_float_t;
+typedef double              vg_lite_double_t;
+typedef char                vg_lite_char;
+typedef char*               vg_lite_string;
+typedef void*               vg_lite_pointer;
+typedef void                vg_lite_void;
+typedef unsigned int        vg_lite_color_t;
+typedef unsigned long       vg_lite_flag_t;
+typedef unsigned long       vg_lite_long_t;
+
+#if __KERNEL__
+# if BITS_PER_LONG == 64
+    typedef unsigned long long vg_lite_uintptr_t;
+# else
+    typedef unsigned int       vg_lite_uintptr_t;
+# endif
+#endif
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
+
-- 
2.39.1

